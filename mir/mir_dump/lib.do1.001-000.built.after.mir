// MIR for `do1` after built

| User Type Annotations
| 0: user_ty: Canonical { value: TypeOf(DefId(2:2545 ~ core[13d3]::convert::From::from), UserArgs { args: [u32, ^0], user_self_ty: None }), max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General(U0)) }] }, span: lib.rs:54:15: 54:24, inferred_ty: fn(u8) -> u32 {<u32 as std::convert::From<u8>>::from}
|
fn do1(_1: &mut u32, _2: &mut u32, _3: &[u8]) -> () {
    debug adler => _1;
    debug sum2 => _2;
    debug buf => _3;
    let mut _0: ();
    let mut _4: u32;
    let mut _5: u8;
    let _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _9: (u32, bool);
    let mut _10: u32;
    let mut _11: (u32, bool);

    bb0: {
        StorageLive(_4);
        StorageLive(_5);
        StorageLive(_6);
        _6 = const 0_usize;
        _7 = Len((*_3));
        _8 = Lt(_6, _7);
        assert(move _8, "index out of bounds: the length is {} but the index is {}", move _7, _6) -> [success: bb1, unwind: bb5];
    }

    bb1: {
        _5 = (*_3)[_6];
        _4 = <u32 as From<u8>>::from(move _5) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        StorageDead(_5);
        _9 = CheckedAdd((*_1), _4);
        assert(!move (_9.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_1), move _4) -> [success: bb3, unwind: bb5];
    }

    bb3: {
        (*_1) = move (_9.0: u32);
        StorageDead(_4);
        StorageDead(_6);
        StorageLive(_10);
        _10 = (*_1);
        _11 = CheckedAdd((*_2), _10);
        assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_2), move _10) -> [success: bb4, unwind: bb5];
    }

    bb4: {
        (*_2) = move (_11.0: u32);
        StorageDead(_10);
        _0 = const ();
        return;
    }

    bb5 (cleanup): {
        resume;
    }
}
