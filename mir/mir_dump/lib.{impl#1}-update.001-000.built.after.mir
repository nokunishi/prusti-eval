// MIR for `<impl at lib.rs:98:1: 98:20>::update` after built

| User Type Annotations
| 0: user_ty: Canonical { value: TypeOf(DefId(2:2545 ~ core[13d3]::convert::From::from), UserArgs { args: [u32, ^0], user_self_ty: None }), max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General(U0)) }] }, span: lib.rs:134:20: 134:29, inferred_ty: fn(u8) -> u32 {<u32 as std::convert::From<u8>>::from}
|
fn <impl at lib.rs:98:1: 98:20>::update(_1: &mut RollingAdler32, _2: u8) -> () {
    debug self => _1;
    debug byte => _2;
    let mut _0: ();
    let _3: u32;
    let mut _4: u8;
    let mut _5: u32;
    let mut _6: u32;
    let mut _7: u32;
    let mut _8: (u32, bool);
    let mut _9: bool;
    let mut _10: u32;
    let mut _11: u32;
    let mut _12: u32;
    let mut _13: (u32, bool);
    let mut _14: bool;
    scope 1 {
        debug byte => _3;
    }

    bb0: {
        StorageLive(_3);
        StorageLive(_4);
        _4 = _2;
        _3 = <u32 as From<u8>>::from(move _4) -> [return: bb1, unwind: bb6];
    }

    bb1: {
        StorageDead(_4);
        FakeRead(ForLet(None), _3);
        StorageLive(_5);
        StorageLive(_6);
        _6 = ((*_1).0: u32);
        StorageLive(_7);
        _7 = _3;
        _8 = CheckedAdd(_6, _7);
        assert(!move (_8.1: bool), "attempt to compute `{} + {}`, which would overflow", move _6, move _7) -> [success: bb2, unwind: bb6];
    }

    bb2: {
        _5 = move (_8.0: u32);
        StorageDead(_7);
        StorageDead(_6);
        _9 = Eq(const _, const 0_u32);
        assert(!move _9, "attempt to calculate the remainder of `{}` with a divisor of zero", _5) -> [success: bb3, unwind: bb6];
    }

    bb3: {
        ((*_1).0: u32) = Rem(move _5, const _);
        StorageDead(_5);
        StorageLive(_10);
        StorageLive(_11);
        _11 = ((*_1).1: u32);
        StorageLive(_12);
        _12 = ((*_1).0: u32);
        _13 = CheckedAdd(_11, _12);
        assert(!move (_13.1: bool), "attempt to compute `{} + {}`, which would overflow", move _11, move _12) -> [success: bb4, unwind: bb6];
    }

    bb4: {
        _10 = move (_13.0: u32);
        StorageDead(_12);
        StorageDead(_11);
        _14 = Eq(const _, const 0_u32);
        assert(!move _14, "attempt to calculate the remainder of `{}` with a divisor of zero", _10) -> [success: bb5, unwind: bb6];
    }

    bb5: {
        ((*_1).1: u32) = Rem(move _10, const _);
        StorageDead(_10);
        _0 = const ();
        StorageDead(_3);
        return;
    }

    bb6 (cleanup): {
        resume;
    }
}
