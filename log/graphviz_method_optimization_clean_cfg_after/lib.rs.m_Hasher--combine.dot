digraph CFG {
graph [fontname=monospace];
node [fontname=monospace];
edge [fontname=monospace];
labelloc="t";
label="Method m_Hasher$$combine";
"block_start" [shape=none,label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center">start (cfg:0)</td></tr><tr><td align="left" balign="left"><font color="orange">// ========== start ==========</font><br/><font color="orange">// Def path: "crc32fast::\{impl#0\}::combine"</font><br/><font color="orange">// Span: src/lib.rs:128:5: 135:6 (#0)</font><br/>__t0 := copy false<br/>__t1 := copy false<br/>__t2 := copy false<br/>__t3 := copy false<br/>__t4 := copy false<br/>__t5 := copy false<br/>__t6 := copy false<br/>__t7 := copy false<br/>__t8 := copy false<br/>__t9 := copy false<br/>__t10 := copy false<br/><font color="orange">// Preconditions:</font><br/>inhale (acc(_1.val_ref, write)) &amp;&amp; ((acc(struct$m_Hasher(_1.val_ref), write)) &amp;&amp; ((acc(_2.val_ref, write)) &amp;&amp; ((acc(stru \ <br/>    ct$m_Hasher(_2.val_ref), read)) &amp;&amp; (true))))<br/>inhale (true) &amp;&amp; ((true) &amp;&amp; (true))<br/>label pre<br/><font color="orange">// ========== bb0 ==========</font><br/>__t0 := copy true<br/><font color="orange">// [mir] StorageLive(_3)</font><br/><font color="orange">// [mir] _3 = ((*_2).0: u64)</font><br/>_3 := builtin$havoc_int()<br/>unfold acc(Ref(struct$m_Hasher)(_2.val_ref), read)<br/>unfold acc(Ref(u64)(_2.val_ref.f$amount), read)<br/>_3 := copy _2.val_ref.f$amount.val_int<br/>label l0<br/><font color="orange">// [mir] _4 = CheckedAdd(((*_1).0: u64), _3)</font><br/>_4 := builtin$havoc_ref()<br/>inhale acc(_4.tuple_0, write)<br/>inhale acc(_4.tuple_0.val_int, write)<br/>inhale acc(_4.tuple_1, write)<br/>inhale acc(_4.tuple_1.val_bool, write)<br/>unfold acc(Ref(struct$m_Hasher)(_1.val_ref), write)<br/>unfold acc(Ref(u64)(_1.val_ref.f$amount), write)<br/>_4.tuple_0.val_int := copy (_1.val_ref.f$amount.val_int) + (_3)<br/>_4.tuple_1.val_bool := copy (((_1.val_ref.f$amount.val_int) + (_3)) &lt; (0)) &#124;&#124; (((_1.val_ref.f$amount.val_int) + (_3)) &gt;  \ <br/>    (18446744073709551615))<br/><font color="orange">// [mir] assert(!move (_4.1: bool), "attempt to compute `\{\} + \{\}`, which would overflow", ((*_1).0: u64), move _3) -&gt; [s \ <br/>    uccess: bb1, unwind: bb11]</font><br/>__t11 := copy _4.tuple_1.val_bool<br/><font color="orange">// Rust assertion: attempt to add with overflow</font><br/>assert !(__t11)<br/><font color="orange">// ========== bb1 ==========</font><br/>__t1 := copy true<br/><font color="orange">// [mir] ((*_1).0: u64) = move (_4.0: u64)</font><br/>_1.val_ref.f$amount := move _4.tuple_0<br/>label l1<br/><font color="orange">// [mir] StorageDead(_3)</font><br/><font color="orange">// [mir] StorageLive(_5)</font><br/><font color="orange">// [mir] StorageLive(_6)</font><br/><font color="orange">// [mir] StorageLive(_7)</font><br/><font color="orange">// [mir] _7 = &amp;'?4 (*_2)</font><br/>_7 := builtin$havoc_ref()<br/>inhale acc(_7.val_ref, write)<br/>_7.val_ref := borrow _2.val_ref // L11<br/>inhale acc(_7.val_ref.f$amount, read)<br/>inhale acc(_7.val_ref.f$state, read)<br/>inhale acc(_7.val_ref.f$amount.val_int, read)<br/>inhale acc(m_State$_beg_$_end_(_7.val_ref.f$state), read)<br/>label l2<br/><font color="orange">// [mir] _6 = &lt;Hasher as std::clone::Clone&gt;::clone(move _7) -&gt; [return: bb2, unwind: bb11]</font><br/>label l3<br/>assert (true) &amp;&amp; (true)<br/>exhale (acc(_7.val_ref, write)) &amp;&amp; ((true) &amp;&amp; (true))<br/>_6 := builtin$havoc_ref()<br/>inhale acc(struct$m_Hasher(_6), write)<br/>transfer perm _7.val_ref --&gt; old[l3](_7.val_ref) // unchecked: true<br/>inhale (true) &amp;&amp; (true)<br/>label l4<br/><font color="orange">// ========== l5 ==========</font><br/><font color="orange">// MIR edge bb1 --&gt; bb2</font><br/><font color="orange">// Expire borrows</font><br/><font color="orange">// expire_borrows ReborrowingDAG(L10,L11,)</font><br/>if (__t1) &amp;&amp; ((__t1) &amp;&amp; (true)) \{<br/>    // expire loan L11<br/>    transfer perm old[l3](_7.val_ref) --&gt; old[l2](_7.val_ref) // unchecked: false<br/>    exhale acc(m_State$_beg_$_end_(old[l2](_7.val_ref).f$state), read)<br/>    exhale acc(old[l2](_7.val_ref).f$amount.val_int, read)<br/>    exhale acc(old[l2](_7.val_ref).f$state, read)<br/>    exhale acc(old[l2](_7.val_ref).f$amount, read)<br/>\} else \{\}<br/><font color="orange">// ========== bb2 ==========</font><br/>__t2 := copy true<br/><font color="orange">// [mir] StorageDead(_7)</font><br/><font color="orange">// [mir] _5 = Hasher::finalize(move _6) -&gt; [return: bb3, unwind: bb11]</font><br/>label l6<br/>assert (true) &amp;&amp; (true)<br/>exhale (acc(struct$m_Hasher(_6), write)) &amp;&amp; (true)<br/>_5 := builtin$havoc_ref()<br/>inhale acc(u32(_5), write)<br/>inhale (true) &amp;&amp; (true)<br/>label l7<br/><font color="orange">// ========== bb3 ==========</font><br/>__t3 := copy true<br/><font color="orange">// [mir] StorageDead(_6)</font><br/><font color="orange">// [mir] FakeRead(ForLet(None), _5)</font><br/><font color="orange">// [mir] FakeRead(ForMatchedPlace(None), ((*_1).1: State))</font><br/><font color="orange">// [mir] _8 = discriminant(((*_1).1: State))</font><br/>_8 := builtin$havoc_int()<br/>_8 := copy m_State$_beg_$_end_$$discriminant$$&lt;&gt;(_1.val_ref.f$state)<br/><font color="orange">// [mir] switchInt(move _8) -&gt; [0: bb4, 1: bb5, otherwise: bb6]</font><br/>__t12 := copy _8<br/><font color="orange">// Ignore default target bb6, as the compiler marked it as unreachable.</font></td></tr><tr><td align="left">GotoSwitch(((__t12) == (0), cfg:3), cfg:2)<br/></td></tr></table>>];
"block_return" [shape=none,label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center">return (cfg:1)</td></tr><tr><td align="left" balign="left"><font color="orange">// ========== bb6 ==========</font><br/>__t4 := copy true<br/><font color="orange">// [mir] unreachable</font></td></tr><tr><td align="left" bgcolor="#82CA9D">Return<br/></td></tr></table>>];
"block_bb0" [shape=none,label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center">bb0 (cfg:2)</td></tr><tr><td align="left" balign="left"><font color="orange">// ========== l8 ==========</font><br/><font color="orange">// MIR edge bb3 --&gt; bb5</font><br/><font color="orange">// ========== bb5 ==========</font><br/>__t5 := copy true<br/><font color="orange">// [mir] StorageLive(_13)</font><br/><font color="orange">// [mir] _13 = &amp;'?5 mut ((((*_1).1: State) as Specialized).0: specialized::pclmulqdq::State)</font><br/>_13 := builtin$havoc_ref()<br/>inhale acc(_13.val_ref, write)<br/>unfold acc(Ref(m_State$_beg_$_end_)&lt;variant \{Specialized\}&gt;(_1.val_ref.f$state), write)<br/>unfold acc(Ref(m_State$_beg_$_end_Specialized)(_1.val_ref.f$state[enum_Specialized]), write)<br/>_13.val_ref := mut borrow _1.val_ref.f$state[enum_Specialized].f$0 // L0<br/>label l10<br/><font color="orange">// [mir] StorageLive(_14)</font><br/><font color="orange">// [mir] _14 = &amp;'?6 mut (*_13)</font><br/>_14 := builtin$havoc_ref()<br/>inhale acc(_14.val_ref, write)<br/>_14.val_ref := mut borrow _13.val_ref // L1<br/>label l11<br/><font color="orange">// [mir] StorageLive(_15)</font><br/><font color="orange">// [mir] _15 = _5</font><br/>_15 := builtin$havoc_ref()<br/>inhale acc(_15.val_int, write)<br/>unfold acc(Ref(u32)(_5), write)<br/>_15.val_int := copy _5.val_int<br/>label l12<br/><font color="orange">// [mir] StorageLive(_16)</font><br/><font color="orange">// [mir] _16 = ((*_2).0: u64)</font><br/>_16 := builtin$havoc_ref()<br/>inhale acc(_16.val_int, write)<br/>_16.val_int := copy _2.val_ref.f$amount.val_int<br/>label l13<br/><font color="orange">// [mir] _0 = specialized::pclmulqdq::State::combine(move _14, move _15, move _16) -&gt; [return: bb9, unwind: bb11]</font><br/>label l14<br/>assert (true) &amp;&amp; ((true) &amp;&amp; ((true) &amp;&amp; (true)))<br/>fold acc(Ref(u32)(_15), write)<br/>fold acc(Ref(u64)(_16), write)<br/>exhale (acc(_14.val_ref, write)) &amp;&amp; ((acc(struct$m_specialized$$pclmulqdq$$State(_14.val_ref), write)) &amp;&amp; ((acc(u32(_15) \ <br/>    , write)) &amp;&amp; ((acc(u64(_16), write)) &amp;&amp; (true))))<br/>_0 := builtin$havoc_ref()<br/>inhale (acc(struct$m_specialized$$pclmulqdq$$State(old[l14](_14.val_ref)), write)) &amp;&amp; (true)<br/>inhale acc(tuple0$(_0), write)<br/>inhale (true) &amp;&amp; ((true) &amp;&amp; (true))<br/>label l15<br/><font color="orange">// ========== l16 ==========</font><br/><font color="orange">// MIR edge bb5 --&gt; bb9</font><br/><font color="orange">// Expire borrows</font><br/><font color="orange">// expire_borrows ReborrowingDAG(L8,L1,L0,)</font><br/><font color="orange">// ========== bb9 ==========</font><br/>__t6 := copy true<br/><font color="orange">// [mir] StorageDead(_16)</font><br/><font color="orange">// [mir] StorageDead(_15)</font><br/><font color="orange">// [mir] StorageDead(_14)</font><br/><font color="orange">// [mir] StorageDead(_13)</font><br/><font color="orange">// [mir] goto -&gt; bb10</font><br/><font color="orange">// ========== l24 ==========</font><br/>fold acc(Ref(m_State$_beg_$_end_Specialized)(_1.val_ref.f$state[enum_Specialized]), write)<br/>fold acc(Ref(m_State$_beg_$_end_)&lt;variant \{Specialized\}&gt;(_1.val_ref.f$state), write)<br/><font color="orange">// drop Acc(_13.val_ref, write) (Acc(_13.val_ref, write))</font></td></tr><tr><td align="left">Goto(cfg:4)<br/></td></tr></table>>];
"block_bb1" [shape=none,label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center">bb1 (cfg:3)</td></tr><tr><td align="left" balign="left"><font color="orange">// ========== l9 ==========</font><br/><font color="orange">// MIR edge bb3 --&gt; bb4</font><br/><font color="orange">// ========== bb4 ==========</font><br/>__t7 := copy true<br/><font color="orange">// [mir] falseEdge -&gt; [real: bb7, imaginary: bb5]</font><br/><font color="orange">// ========== bb7 ==========</font><br/>__t8 := copy true<br/><font color="orange">// [mir] StorageLive(_9)</font><br/><font color="orange">// [mir] _9 = &amp;'?7 mut ((((*_1).1: State) as Baseline).0: baseline::State)</font><br/>_9 := builtin$havoc_ref()<br/>inhale acc(_9.val_ref, write)<br/>unfold acc(Ref(m_State$_beg_$_end_)&lt;variant \{Baseline\}&gt;(_1.val_ref.f$state), write)<br/>unfold acc(Ref(m_State$_beg_$_end_Baseline)(_1.val_ref.f$state[enum_Baseline]), write)<br/>_9.val_ref := mut borrow _1.val_ref.f$state[enum_Baseline].f$0 // L2<br/>label l17<br/><font color="orange">// [mir] StorageLive(_10)</font><br/><font color="orange">// [mir] _10 = &amp;'?8 mut (*_9)</font><br/>_10 := builtin$havoc_ref()<br/>inhale acc(_10.val_ref, write)<br/>_10.val_ref := mut borrow _9.val_ref // L3<br/>label l18<br/><font color="orange">// [mir] StorageLive(_11)</font><br/><font color="orange">// [mir] _11 = _5</font><br/>_11 := builtin$havoc_ref()<br/>inhale acc(_11.val_int, write)<br/>unfold acc(Ref(u32)(_5), write)<br/>_11.val_int := copy _5.val_int<br/>label l19<br/><font color="orange">// [mir] StorageLive(_12)</font><br/><font color="orange">// [mir] _12 = ((*_2).0: u64)</font><br/>_12 := builtin$havoc_ref()<br/>inhale acc(_12.val_int, write)<br/>_12.val_int := copy _2.val_ref.f$amount.val_int<br/>label l20<br/><font color="orange">// [mir] _0 = baseline::State::combine(move _10, move _11, move _12) -&gt; [return: bb8, unwind: bb11]</font><br/>label l21<br/>assert (true) &amp;&amp; ((true) &amp;&amp; ((true) &amp;&amp; (true)))<br/>fold acc(Ref(u32)(_11), write)<br/>fold acc(Ref(u64)(_12), write)<br/>exhale (acc(_10.val_ref, write)) &amp;&amp; ((acc(struct$m_baseline$$State(_10.val_ref), write)) &amp;&amp; ((acc(u32(_11), write)) &amp;&amp; ( \ <br/>    (acc(u64(_12), write)) &amp;&amp; (true))))<br/>_0 := builtin$havoc_ref()<br/>inhale (acc(struct$m_baseline$$State(old[l21](_10.val_ref)), write)) &amp;&amp; (true)<br/>inhale acc(tuple0$(_0), write)<br/>inhale (true) &amp;&amp; ((true) &amp;&amp; (true))<br/>label l22<br/><font color="orange">// ========== l23 ==========</font><br/><font color="orange">// MIR edge bb7 --&gt; bb8</font><br/><font color="orange">// Expire borrows</font><br/><font color="orange">// expire_borrows ReborrowingDAG(L9,L3,L2,)</font><br/><font color="orange">// ========== bb8 ==========</font><br/>__t9 := copy true<br/><font color="orange">// [mir] StorageDead(_12)</font><br/><font color="orange">// [mir] StorageDead(_11)</font><br/><font color="orange">// [mir] StorageDead(_10)</font><br/><font color="orange">// [mir] StorageDead(_9)</font><br/><font color="orange">// [mir] goto -&gt; bb10</font><br/><font color="orange">// ========== l26 ==========</font><br/>fold acc(Ref(m_State$_beg_$_end_Baseline)(_1.val_ref.f$state[enum_Baseline]), write)<br/>fold acc(Ref(m_State$_beg_$_end_)&lt;variant \{Baseline\}&gt;(_1.val_ref.f$state), write)<br/><font color="orange">// drop Acc(_9.val_ref, write) (Acc(_9.val_ref, write))</font></td></tr><tr><td align="left">Goto(cfg:4)<br/></td></tr></table>>];
"block_l5" [shape=none,label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center">l5 (cfg:4)</td></tr><tr><td align="left" balign="left"><font color="orange">// ========== bb10 ==========</font><br/>__t10 := copy true<br/><font color="orange">// [mir] StorageDead(_5)</font><br/><font color="orange">// [mir] return</font><br/><font color="orange">// ========== return ==========</font><br/><font color="orange">// Target of any 'return' statement.</font><br/><font color="orange">// Exhale postcondition</font><br/>label l25<br/><font color="orange">// Fold predicates for &amp;mut args and transfer borrow permissions to old</font><br/>fold acc(Ref(u64)(_1.val_ref.f$amount), write)<br/>fold acc(Ref(struct$m_Hasher)(_1.val_ref), write)<br/>obtain acc(struct$m_Hasher(_1.val_ref), write)<br/>_old$pre$0 := move _1.val_ref<br/>fold acc(Ref(u64)(_2.val_ref.f$amount), read)<br/>fold acc(Ref(struct$m_Hasher)(_2.val_ref), read)<br/>obtain acc(struct$m_Hasher(_2.val_ref), write)<br/>_old$pre$1 := move _2.val_ref<br/><font color="orange">// Fold the result</font><br/>obtain acc(tuple0$(_0), write)<br/><font color="orange">// Assert possible strengthening</font><br/><font color="orange">// Assert functional specification of postcondition</font><br/><font color="orange">// Assert type invariants</font><br/>assert (true) &amp;&amp; ((true) &amp;&amp; (true))<br/><font color="orange">// Exhale permissions of postcondition (1/3)</font><br/>exhale (acc(struct$m_Hasher(_old$pre$0), write)) &amp;&amp; ((acc(struct$m_Hasher(_old$pre$1), read)) &amp;&amp; (true))<br/><font color="orange">// Exhale permissions of postcondition (2/3)</font><br/>exhale acc(tuple0$(_0), write)<br/><font color="orange">// Exhale permissions of postcondition (3/3)</font></td></tr><tr><td align="left" bgcolor="#82CA9D">Return<br/></td></tr></table>>];
"block_start" -> "block_bb1";
"block_start" -> "block_bb0";
"block_bb0" -> "block_l5";
"block_bb1" -> "block_l5";
}
