digraph CFG {
graph [fontname=monospace];
node [fontname=monospace];
edge [fontname=monospace];
labelloc="t";
label="Method m_Hasher$$internal_new_specialized";
"block_start" [shape=none,label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center">start (cfg:0)</td></tr><tr><td align="left" balign="left"><font color="orange">// ========== start ==========</font><br/><font color="orange">// Def path: "crc32fast::\{impl#0\}::internal_new_specialized"</font><br/><font color="orange">// Span: src/lib.rs:89:5: 99:6 (#0)</font><br/>__t0 := copy false<br/>__t1 := copy false<br/>__t2 := copy false<br/>__t3 := copy false<br/>__t4 := copy false<br/>__t5 := copy false<br/><font color="orange">// Preconditions:</font><br/>inhale (acc(u32(_1), write)) &amp;&amp; (true)<br/>inhale true<br/>inhale (true) &amp;&amp; (true)<br/>inhale true<br/>label pre</td></tr><tr><td align="left">Goto(cfg:2)<br/></td></tr></table>>];
"block_return" [shape=none,label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center">return (cfg:1)</td></tr><tr><td align="left" balign="left"><font color="orange">// ========== return ==========</font><br/><font color="orange">// Target of any 'return' statement.</font><br/><font color="orange">// Exhale postcondition</font><br/>label l11<br/><font color="orange">// Fold predicates for &amp;mut args and transfer borrow permissions to old</font><br/><font color="orange">// Fold the result</font><br/>obtain acc(m_std$$option$$Option$_beg_$struct$m_Hasher$_end_(_0), write)<br/><font color="orange">// Assert possible strengthening</font><br/><font color="orange">// Assert functional specification of postcondition</font><br/>assert true<br/><font color="orange">// Assert type invariants</font><br/>assert (true) &amp;&amp; (true)<br/><font color="orange">// Exhale permissions of postcondition (1/3)</font><br/>exhale true<br/><font color="orange">// Exhale permissions of postcondition (2/3)</font><br/>exhale acc(m_std$$option$$Option$_beg_$struct$m_Hasher$_end_(_0), write)<br/><font color="orange">// Exhale permissions of postcondition (3/3)</font></td></tr><tr><td align="left" bgcolor="#82CA9D">Return<br/></td></tr></table>>];
"block_bb0" [shape=none,label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center">bb0 (cfg:2)</td></tr><tr><td align="left" balign="left"><font color="orange">// ========== bb0 ==========</font><br/>__t0 := copy true<br/><font color="orange">// [mir] StorageLive(_2)</font><br/><font color="orange">// [mir] StorageLive(_3)</font><br/><font color="orange">// [mir] StorageLive(_4)</font><br/><font color="orange">// [mir] _4 = _1</font><br/>_4 := builtin$havoc_ref()<br/>inhale acc(_4.val_int, write)<br/>_4.val_int := copy _1.val_int<br/>label l0<br/><font color="orange">// [mir] _3 = specialized::pclmulqdq::State::new(move _4) -&gt; [return: bb1, unwind: bb6]</font><br/>label l1<br/>assert true<br/>assert (true) &amp;&amp; (true)<br/>exhale (acc(u32(_4), write)) &amp;&amp; (true)<br/>_3 := builtin$havoc_ref()<br/>inhale true<br/>inhale acc(m_std$$option$$Option$_beg_$struct$m_specialized$$pclmulqdq$$State$_end_(_3), write)<br/>inhale (true) &amp;&amp; (true)<br/>inhale true<br/>exhale true<br/>label l2</td></tr><tr><td align="left">Goto(cfg:3)<br/></td></tr></table>>];
"block_bb1" [shape=none,label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center">bb1 (cfg:3)</td></tr><tr><td align="left" balign="left"><font color="orange">// ========== bb1 ==========</font><br/>__t1 := copy true<br/><font color="orange">// [mir] StorageDead(_4)</font><br/><font color="orange">// [mir] FakeRead(ForMatchedPlace(None), _3)</font><br/><font color="orange">// [mir] _5 = discriminant(_3)</font><br/>_5 := builtin$havoc_ref()<br/>inhale acc(_5.val_int, write)<br/>_5.val_int := copy m_std$$option$$Option$_beg_$struct$m_specialized$$pclmulqdq$$State$_end_$$discriminant$$&lt;&gt;(_3)<br/><font color="orange">// [mir] switchInt(move _5) -&gt; [1: bb2, otherwise: bb4]</font><br/>__t6 := copy _5.val_int</td></tr><tr><td align="left">GotoSwitch(((__t6) == (1), cfg:5), cfg:4)<br/></td></tr></table>>];
"block_l3" [shape=none,label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center">l3 (cfg:4)</td></tr><tr><td align="left" balign="left"><font color="orange">// ========== l3 ==========</font><br/><font color="orange">// MIR edge bb1 --&gt; bb4</font></td></tr><tr><td align="left">Goto(cfg:6)<br/></td></tr></table>>];
"block_l4" [shape=none,label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center">l4 (cfg:5)</td></tr><tr><td align="left" balign="left"><font color="orange">// ========== l4 ==========</font><br/><font color="orange">// MIR edge bb1 --&gt; bb2</font></td></tr><tr><td align="left">Goto(cfg:7)<br/></td></tr></table>>];
"block_bb4" [shape=none,label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center">bb4 (cfg:6)</td></tr><tr><td align="left" balign="left"><font color="orange">// ========== bb4 ==========</font><br/>__t2 := copy true<br/><font color="orange">// [mir] _2 = const ()</font><br/><font color="orange">// [mir] StorageDead(_3)</font><br/><font color="orange">// [mir] StorageDead(_2)</font><br/><font color="orange">// [mir] _0 = std::option::Option::&lt;Hasher&gt;::None</font><br/>_0 := builtin$havoc_ref()<br/>inhale acc(m_std$$option$$Option$_beg_$struct$m_Hasher$_end_(_0), write)<br/>inhale (m_std$$option$$Option$_beg_$struct$m_Hasher$_end_$$discriminant$$&lt;&gt;(_0)) == (0)<br/><font color="orange">// [mir] goto -&gt; bb5</font></td></tr><tr><td align="left">Goto(cfg:9)<br/></td></tr></table>>];
"block_bb2" [shape=none,label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center">bb2 (cfg:7)</td></tr><tr><td align="left" balign="left"><font color="orange">// ========== bb2 ==========</font><br/>__t3 := copy true<br/><font color="orange">// [mir] falseEdge -&gt; [real: bb3, imaginary: bb4]</font></td></tr><tr><td align="left">Goto(cfg:8)<br/></td></tr></table>>];
"block_bb3" [shape=none,label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center">bb3 (cfg:8)</td></tr><tr><td align="left" balign="left"><font color="orange">// ========== bb3 ==========</font><br/>__t4 := copy true<br/><font color="orange">// [mir] StorageLive(_6)</font><br/><font color="orange">// [mir] _6 = move ((_3 as Some).0: specialized::pclmulqdq::State)</font><br/>_6 := move _3[enum_Some].f$0<br/>label l5<br/><font color="orange">// [mir] StorageLive(_8)</font><br/><font color="orange">// [mir] StorageLive(_9)</font><br/><font color="orange">// [mir] StorageLive(_10)</font><br/><font color="orange">// [mir] _10 = move _6</font><br/>_10 := move _6<br/>label l6<br/><font color="orange">// [mir] _9 = State::Specialized(move _10)</font><br/>_9 := builtin$havoc_ref()<br/>inhale acc(m_State$_beg_$_end_(_9), write)<br/>inhale (m_State$_beg_$_end_$$discriminant$$&lt;&gt;(_9)) == (1)<br/>downcast _9 to enum_Specialized<br/>_9[enum_Specialized].f$0 := move _10<br/>label l7<br/><font color="orange">// [mir] StorageDead(_10)</font><br/><font color="orange">// [mir] _8 = Hasher \{ amount: const 0_u64, state: move _9 \}</font><br/>_8 := builtin$havoc_ref()<br/>inhale acc(struct$m_Hasher(_8), write)<br/>_aux_havoc_u64 := builtin$havoc_ref()<br/>_8.f$amount := move _aux_havoc_u64<br/>inhale acc(_8.f$amount.val_int, write)<br/>_8.f$amount.val_int := copy 0<br/>_8.f$state := move _9<br/>label l8<br/><font color="orange">// [mir] StorageDead(_9)</font><br/><font color="orange">// [mir] _0 = std::option::Option::&lt;Hasher&gt;::Some(move _8)</font><br/>_0 := builtin$havoc_ref()<br/>inhale acc(m_std$$option$$Option$_beg_$struct$m_Hasher$_end_(_0), write)<br/>inhale (m_std$$option$$Option$_beg_$struct$m_Hasher$_end_$$discriminant$$&lt;&gt;(_0)) == (1)<br/>downcast _0 to enum_Some<br/>_0[enum_Some].f$0 := move _8<br/>label l9<br/><font color="orange">// [mir] StorageDead(_8)</font><br/><font color="orange">// [mir] StorageDead(_6)</font><br/><font color="orange">// [mir] StorageDead(_3)</font><br/><font color="orange">// [mir] StorageDead(_2)</font><br/><font color="orange">// [mir] goto -&gt; bb5</font></td></tr><tr><td align="left">Goto(cfg:9)<br/></td></tr></table>>];
"block_bb5" [shape=none,label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center">bb5 (cfg:9)</td></tr><tr><td align="left" balign="left"><font color="orange">// ========== bb5 ==========</font><br/>__t5 := copy true<br/><font color="orange">// [mir] return</font></td></tr><tr><td align="left">Goto(cfg:1)<br/></td></tr></table>>];
"block_start" -> "block_bb0";
"block_bb0" -> "block_bb1";
"block_bb1" -> "block_l4";
"block_bb1" -> "block_l3";
"block_l3" -> "block_bb4";
"block_l4" -> "block_bb2";
"block_bb4" -> "block_bb5";
"block_bb2" -> "block_bb3";
"block_bb3" -> "block_bb5";
"block_bb5" -> "block_return";
}
