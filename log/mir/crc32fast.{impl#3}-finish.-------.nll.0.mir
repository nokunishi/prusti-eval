// MIR for `<impl at src/lib.rs:150:1: 150:29>::finish` 0 nll

| Free Region Mapping
| '?0 | Global | ['?0, '?2, '?1]
| '?1 | Local | ['?2, '?1]
| '?2 | Local | ['?2]
|
| Inferred Region Values
| '?0 | U0 | {bb0[0..=4], bb1[0..=1], bb2[0..=1], bb3[0..=1], bb4[0], '?0, '?1, '?2}
| '?1 | U0 | {bb0[0..=4], bb1[0..=1], bb2[0..=1], bb3[0..=1], bb4[0], '?1}
| '?2 | U0 | {bb0[0..=4], bb1[0..=1], bb2[0..=1], bb3[0..=1], bb4[0], '?2}
| '?3 | U0 | {bb0[3..=4]}
| '?4 | U0 | {bb0[0..=4], bb1[0..=1], bb2[0..=1], bb3[0..=1], bb4[0], '?1}
| '?5 | U0 | {bb0[4]}
| '?6 | U0 | {bb0[4]}
|
| Inference Constraints
| '?0 live at {bb0[0..=4], bb1[0..=1], bb2[0..=1], bb3[0..=1], bb4[0]}
| '?1 live at {bb0[0..=4], bb1[0..=1], bb2[0..=1], bb3[0..=1], bb4[0]}
| '?2 live at {bb0[0..=4], bb1[0..=1], bb2[0..=1], bb3[0..=1], bb4[0]}
| '?3 live at {bb0[3]}
| '?5 live at {bb0[4]}
| '?6 live at {bb0[4]}
| '?1: '?4 due to BoringNoLocation at All(src/lib.rs:155:15: 155:20) (src/lib.rs:155:15: 155:20 (#0)
| '?3: '?5 due to Boring at Single(bb0[3]) (src/lib.rs:156:19: 156:23 (#0)
| '?4: '?1 due to BoringNoLocation at All(src/lib.rs:155:15: 155:20) (src/lib.rs:155:15: 155:20 (#0)
| '?4: '?3 due to Boring at Single(bb0[3]) (src/lib.rs:156:19: 156:23 (#0)
| '?5: '?6 due to CallArgument(Some(FnDef(DefId(2:2280 ~ core[5e8a]::clone::Clone::clone), [Adt(Hasher, [])]))) at Single(bb0[4]) (src/lib.rs:156:19: 156:31 (#0)
|
| User Type Annotations
| 0: user_ty: Canonical { value: TypeOf(DefId(2:2535 ~ core[5e8a]::convert::From::from), UserArgs { args: [u64, ^0], user_self_ty: None }), max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General(U0)) }] }, span: src/lib.rs:156:9: 156:18, inferred_ty: fn(u32) -> u64 {<u64 as std::convert::From<u32>>::from}
|
fn <impl at src/lib.rs:150:1: 150:29>::finish(_1: &'?4 Hasher) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let mut _2: u32;
    let mut _3: Hasher;
    let mut _4: &'?5 Hasher;

    bb0: {
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = &'?3 (*_1);
        _3 = <Hasher as std::clone::Clone>::clone(move _4) -> [return: bb1, unwind: bb4];
    }

    bb1: {
        StorageDead(_4);
        _2 = Hasher::finalize(move _3) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        StorageDead(_3);
        _0 = <u64 as std::convert::From<u32>>::from(move _2) -> [return: bb3, unwind: bb4];
    }

    bb3: {
        StorageDead(_2);
        return;
    }

    bb4 (cleanup): {
        resume;
    }
}
