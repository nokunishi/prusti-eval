digraph CFG {
graph [fontname=monospace];
node [fontname=monospace];
edge [fontname=monospace];
labelloc="t";
label="Method m_Hasher$$new_with_initial$$$opencur$closure$sharp$0$closecur$";
"block_start" [shape=none,label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center">start (cfg:0)</td></tr><tr><td align="left" balign="left"><font color="orange">// ========== start ==========</font><br/><font color="orange">// Def path: "crc32fast::\{impl#0\}::new_with_initial::\{closure#0\}"</font><br/><font color="orange">// Span: src/lib.rs:75:61: 75:97 (#0)</font><br/>__t0 := copy false<br/>__t1 := copy false<br/><font color="orange">// Preconditions:</font><br/>inhale (acc(closure$m_Hasher$$new_with_initial$$$opencur$closure$sharp$0$closecur$(_1), write)) &amp;&amp; (true)<br/>inhale (true) &amp;&amp; (true)<br/>label pre</td></tr><tr><td align="left">Goto(cfg:2)<br/></td></tr></table>>];
"block_return" [shape=none,label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center">return (cfg:1)</td></tr><tr><td align="left" balign="left"><font color="orange">// ========== return ==========</font><br/><font color="orange">// Target of any 'return' statement.</font><br/><font color="orange">// Exhale postcondition</font><br/>label l4<br/><font color="orange">// Fold predicates for &amp;mut args and transfer borrow permissions to old</font><br/><font color="orange">// Fold the result</font><br/>obtain acc(struct$m_Hasher(_0), write)<br/><font color="orange">// Assert possible strengthening</font><br/><font color="orange">// Assert functional specification of postcondition</font><br/><font color="orange">// Assert type invariants</font><br/>assert (true) &amp;&amp; (true)<br/><font color="orange">// Exhale permissions of postcondition (1/3)</font><br/><font color="orange">// Exhale permissions of postcondition (2/3)</font><br/>exhale acc(struct$m_Hasher(_0), write)<br/><font color="orange">// Exhale permissions of postcondition (3/3)</font></td></tr><tr><td align="left" bgcolor="#82CA9D">Return<br/></td></tr></table>>];
"block_bb0" [shape=none,label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center">bb0 (cfg:2)</td></tr><tr><td align="left" balign="left"><font color="orange">// ========== bb0 ==========</font><br/>__t0 := copy true<br/><font color="orange">// [mir] StorageLive(_2)</font><br/><font color="orange">// [mir] _2 = (*(_1.0: &amp;'?3 u32))</font><br/>_2 := builtin$havoc_ref()<br/>inhale acc(_2.val_int, write)<br/>unfold acc(Ref(closure$m_Hasher$$new_with_initial$$$opencur$closure$sharp$0$closecur$)(_1), write)<br/>unfold acc(Ref(ref$u32)(_1.closure_0), write)<br/>unfold acc(Ref(u32)(_1.closure_0.val_ref), write)<br/>_2.val_int := copy _1.closure_0.val_ref.val_int<br/>label l0<br/><font color="orange">// [mir] _0 = Hasher::internal_new_baseline(move _2) -&gt; [return: bb1, unwind: bb2]</font><br/>label l1<br/>assert (true) &amp;&amp; (true)<br/>fold acc(Ref(u32)(_2), write)<br/>exhale (acc(u32(_2), write)) &amp;&amp; (true)<br/>_0 := builtin$havoc_ref()<br/>inhale acc(struct$m_Hasher(_0), write)<br/>inhale (true) &amp;&amp; (true)<br/>label l2</td></tr><tr><td align="left">Goto(cfg:3)<br/></td></tr></table>>];
"block_bb1" [shape=none,label=<<table border="0" cellborder="1" cellspacing="0"><tr><td bgcolor="gray" align="center">bb1 (cfg:3)</td></tr><tr><td align="left" balign="left"><font color="orange">// ========== bb1 ==========</font><br/>__t1 := copy true<br/><font color="orange">// [mir] StorageDead(_2)</font><br/><font color="orange">// [mir] return</font></td></tr><tr><td align="left">Goto(cfg:1)<br/></td></tr></table>>];
"block_start" -> "block_bb0";
"block_bb0" -> "block_bb1";
"block_bb1" -> "block_return";
}
