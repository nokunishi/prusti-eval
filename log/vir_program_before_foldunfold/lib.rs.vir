method m_baseline$$update_fast_16(...)
    returns (_0: Ref(u32))
{
  label stub // 0
    // ========== stub ==========
    // Def path: "crc32fast::baseline::update_fast_16"
    // Span: src/baseline.rs:30:1: 59:2 (#0)
    Return
  label end_of_method
}


method m_baseline$$update_slow(...)
    returns (_0: Ref(u32))
{
  label stub // 0
    // ========== stub ==========
    // Def path: "crc32fast::baseline::update_slow"
    // Span: src/baseline.rs:61:1: 69:2 (#0)
    Return
  label end_of_method
}


method m_combine$$gf2_matrix_times(...)
    returns (_0: Ref(u32))
{
  label stub // 0
    // ========== stub ==========
    // Def path: "crc32fast::combine::gf2_matrix_times"
    // Span: src/combine.rs:3:1: 14:2 (#0)
    Return
  label end_of_method
}


method m_combine$$gf2_matrix_square(...)
    returns (_0: Ref(tuple0$))
{
  label stub // 0
    // ========== stub ==========
    // Def path: "crc32fast::combine::gf2_matrix_square"
    // Span: src/combine.rs:16:1: 20:2 (#0)
    Return
  label end_of_method
}


method m_combine$$combine(...)
    returns (_0: Ref(u32))
{
  label stub // 0
    // ========== stub ==========
    // Def path: "crc32fast::combine::combine"
    // Span: src/combine.rs:22:1: 77:2 (#0)
    Return
  label end_of_method
}


method m_specialized$$pclmulqdq$$calculate(...)
    returns (_0: Ref(u32))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    __t18: Bool
    __t19: Bool
    __t20: Bool
    __t21: Bool
    __t22: Bool
    __t23: Bool
    __t24: Bool
    __t25: Bool
    __t26: Bool
    __t27: Bool
    __t28: Bool
    __t29: Bool
    __t30: Bool
    __t31: Bool
    __t32: Bool
    __t33: Bool
    __t34: Bool
    __t35: Bool
    __t36: Bool
    __t37: Bool
    __t38: Bool
    __t39: Bool
    __t40: Bool
    __t41: Bool
    __t42: Bool
    __t43: Bool
    __t44: Bool
    __t45: Bool
    __t46: Bool
    __t47: Bool
    __t48: Bool
    __t49: Bool
    __t50: Bool
    __t51: Bool
    __t52: Bool
    __t53: Bool
    __t54: Bool
    __t55: Bool
    __t56: Bool
    __t57: Bool
    __t58: Bool
    __t59: Bool
    __t60: Bool
    __t61: Bool
    __t62: Bool
    __t63: Bool
    __t64: Bool
    _preserve$0: Ref(AuxRef)
    __t65: Bool
    __t66: Bool
    __t67: Bool
    _preserve$1: Ref(AuxRef)
    __t68: Bool
    __t69: Bool
    __t70: Bool
    _old$pre$1: Ref(Slice$u8)
    _1: Ref(u32)
    _2: Ref(ref$Slice$u8)
    _3: Ref(tuple0$)
    _4: Ref(bool)
    _5: Ref(usize)
    _6: Ref(ref$Slice$u8)
    _7: Ref(Never)
    _8: Ref(u32)
    _9: Ref(ref$Slice$u8)
    _10: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _11: Ref(ref$ref$Slice$u8)
    _12: Ref(ref$ref$Slice$u8)
    _13: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _14: Ref(ref$ref$Slice$u8)
    _15: Ref(ref$ref$Slice$u8)
    _16: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _17: Ref(ref$ref$Slice$u8)
    _18: Ref(ref$ref$Slice$u8)
    _19: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _20: Ref(ref$ref$Slice$u8)
    _21: Ref(ref$ref$Slice$u8)
    _22: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _23: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _24: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _25: Ref(i32)
    _26: Ref(u32)
    _27: Ref(u32)
    _28: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _29: Ref(tuple0$)
    _30: Ref(tuple0$)
    _31: Ref(bool)
    _32: Ref(usize)
    _33: Ref(ref$Slice$u8)
    _34: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _35: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _36: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _37: Ref(ref$ref$Slice$u8)
    _38: Ref(ref$ref$Slice$u8)
    _39: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _40: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _41: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _42: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _43: Ref(ref$ref$Slice$u8)
    _44: Ref(ref$ref$Slice$u8)
    _45: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _46: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _47: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _48: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _49: Ref(ref$ref$Slice$u8)
    _50: Ref(ref$ref$Slice$u8)
    _51: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _52: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _53: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _54: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _55: Ref(ref$ref$Slice$u8)
    _56: Ref(ref$ref$Slice$u8)
    _57: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _58: Ref(Never)
    _59: Ref(tuple0$)
    _60: Ref(Never)
    _61: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _62: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _63: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _64: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _65: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _66: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _67: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _68: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _69: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _70: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _71: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _72: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _73: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _74: Ref(tuple0$)
    _75: Ref(bool)
    _76: Ref(usize)
    _77: Ref(ref$Slice$u8)
    _78: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _79: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _80: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _81: Ref(ref$ref$Slice$u8)
    _82: Ref(ref$ref$Slice$u8)
    _83: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _84: Ref(Never)
    _85: Ref(tuple0$)
    _86: Ref(Never)
    _87: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _88: Ref(ref$Str)
    _89: Ref(ref$Str)
    _90: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _91: Ref(tuple0$)
    _92: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _93: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _94: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _95: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _96: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _97: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _98: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _99: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _100: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _101: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _102: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _103: Ref(i32)
    _104: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _105: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _106: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _107: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _108: Ref(ref$Str)
    _109: Ref(ref$Str)
    _110: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _111: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _112: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _113: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _114: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _115: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _116: Ref(i32)
    _117: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _118: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _119: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _120: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _121: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _122: Ref(i32)
    _123: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _124: Ref(u32)
    _125: Ref(i32)
    _126: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _127: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _128: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _129: Ref(bool)
    _130: Ref(ref$Slice$u8)
    _131: Ref(u32)
    _132: Ref(u32)
    _133: Ref(ref$Slice$u8)
    _134: Ref(u32)
    _t135: Ref(i64)
    _t136: Ref(i64)
    _t137: Ref(i64)
    _t138: Ref(i64)
    _t139: Ref(i64)
    _t140: Ref(i32)
    _t141: Ref(i32)
    _t142: Ref(i32)
    _t143: Ref(i64)
    _t144: Ref(i64)
    _t145: Ref(i64)
    _t146: Ref(i64)
    _t147: Ref(i32)
    _t148: Ref(i32)
    _t149: Ref(i32)
    _t150: Ref(i32)
    _t151: Ref(i32)
    _t152: Ref(i32)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::specialized::pclmulqdq::calculate"
    // Span: src/specialized/pclmulqdq.rs:92:1: 190:2 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    __t12 := copy false
    __t13 := copy false
    __t14 := copy false
    __t15 := copy false
    __t16 := copy false
    __t17 := copy false
    __t18 := copy false
    __t19 := copy false
    __t20 := copy false
    __t21 := copy false
    __t22 := copy false
    __t23 := copy false
    __t24 := copy false
    __t25 := copy false
    __t26 := copy false
    __t27 := copy false
    __t28 := copy false
    __t29 := copy false
    __t30 := copy false
    __t31 := copy false
    __t32 := copy false
    __t33 := copy false
    __t34 := copy false
    __t35 := copy false
    __t36 := copy false
    __t37 := copy false
    __t38 := copy false
    __t39 := copy false
    __t40 := copy false
    __t41 := copy false
    __t42 := copy false
    __t43 := copy false
    __t44 := copy false
    __t45 := copy false
    __t46 := copy false
    __t47 := copy false
    __t48 := copy false
    __t49 := copy false
    __t50 := copy false
    __t51 := copy false
    __t52 := copy false
    __t53 := copy false
    __t54 := copy false
    __t55 := copy false
    __t56 := copy false
    __t57 := copy false
    __t58 := copy false
    __t59 := copy false
    __t60 := copy false
    __t61 := copy false
    __t62 := copy false
    // Preconditions:
    inhale (acc(u32(_1), write)) && ((acc(_2.val_ref, write)) && ((acc(Slice$u8(_2.val_ref), read)) && (true)))
    inhale true
    inhale (true) && ((true) && (true))
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l210
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(Slice$u8(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(u32(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(Slice$u8(_old$pre$1), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(u32(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] StorageLive(_5)
    // [mir] StorageLive(_6)
    // [mir] _6 = &'?3 (*_2)
    _6 := builtin$havoc_ref()
    inhale acc(_6.val_ref, write)
    _6.val_ref := borrow _2.val_ref // L47
    label l0
    // [mir] _5 = core::slice::<impl [u8]>::len(move _6) -> [return: bb1, unwind: bb63]
    label l1
    _5 := builtin$havoc_ref()
    inhale acc(_5.val_int, write)
    _5.val_int := copy Slice$len<Ref(u8)>(_6.val_ref)
    transfer perm _6.val_ref --> old[l1](_6.val_ref) // unchecked: false
    Goto(cfg:3)
  label l2 // 3
    // ========== l2 ==========
    // MIR edge bb0 --> bb1
    // Expire borrows
    expire_borrows ReborrowingDAG(L37,L47,)

    Goto(cfg:4)
  label bb1 // 4
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_6)
    // [mir] _4 = Lt(move _5, const 128_usize)
    _4 := builtin$havoc_ref()
    inhale acc(_4.val_bool, write)
    _4.val_bool := copy (_5.val_int) < (128)
    // [mir] switchInt(move _4) -> [0: bb4, otherwise: bb2]
    __t63 := copy _4.val_bool
    GotoSwitch([(Local(Local { variable: __t63: Bool, position: Position { line: 0, column: 0, id: 0 } }), cfg:6)], cfg:5)
  label l3 // 5
    // ========== l3 ==========
    // MIR edge bb1 --> bb4
    Goto(cfg:10)
  label l4 // 6
    // ========== l4 ==========
    // MIR edge bb1 --> bb2
    Goto(cfg:7)
  label bb2 // 7
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] StorageDead(_5)
    // [mir] StorageLive(_8)
    // [mir] _8 = _1
    _8 := builtin$havoc_ref()
    inhale acc(_8.val_int, write)
    _8.val_int := copy _1.val_int
    label l5
    // [mir] StorageLive(_9)
    // [mir] _9 = &'?4 (*_2)
    _9 := builtin$havoc_ref()
    inhale acc(_9.val_ref, write)
    _9.val_ref := borrow _2.val_ref // L44
    label l6
    // [mir] _0 = baseline::update_fast_16(move _8, move _9) -> [return: bb3, unwind: bb63]
    label l7
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(u32(_8), write)) && ((acc(_9.val_ref, write)) && ((true) && (true)))
    _0 := builtin$havoc_ref()
    inhale true
    inhale acc(u32(_0), write)
    transfer perm _9.val_ref --> old[l7](_9.val_ref) // unchecked: true
    inhale (true) && (true)
    inhale true
    exhale true
    label l8
    Goto(cfg:8)
  label l9 // 8
    // ========== l9 ==========
    // MIR edge bb2 --> bb3
    // Expire borrows
    expire_borrows ReborrowingDAG(L34,L44,)

    Goto(cfg:9)
  label bb3 // 9
    // ========== bb3 ==========
    __t3 := copy true
    // [mir] StorageDead(_9)
    // [mir] StorageDead(_8)
    // [mir] StorageDead(_4)
    // [mir] StorageDead(_3)
    // [mir] goto -> bb62
    Goto(cfg:123)
  label bb4 // 10
    // ========== bb4 ==========
    __t4 := copy true
    // [mir] StorageDead(_5)
    // [mir] _3 = const ()
    // [mir] StorageDead(_4)
    // [mir] StorageDead(_3)
    // [mir] StorageLive(_10)
    // [mir] StorageLive(_11)
    // [mir] StorageLive(_12)
    // [mir] _12 = &'?5 mut _2
    _12 := builtin$havoc_ref()
    inhale acc(_12.val_ref, write)
    _12.val_ref := mut borrow _2 // L0
    label l10
    // [mir] _11 = &'?6 mut (*_12)
    _11 := builtin$havoc_ref()
    inhale acc(_11.val_ref, write)
    _11.val_ref := mut borrow _12.val_ref // L1
    label l11
    // [mir] _10 = specialized::pclmulqdq::get(move _11) -> [return: bb5, unwind: bb63]
    label l12
    assert true
    assert (true) && (true)
    exhale (acc(_11.val_ref, write)) && ((acc(ref$Slice$u8(_11.val_ref), write)) && (true))
    _10 := builtin$havoc_ref()
    inhale (acc(ref$Slice$u8(old[l12](_11.val_ref)), write)) && (true)
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_10), write)
    inhale (true) && ((true) && (true))
    inhale true
    exhale true
    label l13
    Goto(cfg:11)
  label l14 // 11
    // ========== l14 ==========
    // MIR edge bb4 --> bb5
    // Expire borrows
    expire_borrows ReborrowingDAG(L32,L1,L0,)

    Goto(cfg:12)
  label bb5 // 12
    // ========== bb5 ==========
    __t5 := copy true
    // [mir] StorageDead(_11)
    // [mir] FakeRead(ForLet(None), _10)
    // [mir] StorageDead(_12)
    // [mir] StorageLive(_13)
    // [mir] StorageLive(_14)
    // [mir] StorageLive(_15)
    // [mir] _15 = &'?7 mut _2
    _15 := builtin$havoc_ref()
    inhale acc(_15.val_ref, write)
    _15.val_ref := mut borrow _2 // L2
    label l15
    // [mir] _14 = &'?8 mut (*_15)
    _14 := builtin$havoc_ref()
    inhale acc(_14.val_ref, write)
    _14.val_ref := mut borrow _15.val_ref // L3
    label l16
    // [mir] _13 = specialized::pclmulqdq::get(move _14) -> [return: bb6, unwind: bb63]
    label l17
    assert true
    assert (true) && (true)
    exhale (acc(_14.val_ref, write)) && ((acc(ref$Slice$u8(_14.val_ref), write)) && (true))
    _13 := builtin$havoc_ref()
    inhale (acc(ref$Slice$u8(old[l17](_14.val_ref)), write)) && (true)
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_13), write)
    inhale (true) && ((true) && (true))
    inhale true
    exhale true
    label l18
    Goto(cfg:13)
  label l19 // 13
    // ========== l19 ==========
    // MIR edge bb5 --> bb6
    // Expire borrows
    expire_borrows ReborrowingDAG(L28,L3,L2,)

    Goto(cfg:14)
  label bb6 // 14
    // ========== bb6 ==========
    __t6 := copy true
    // [mir] StorageDead(_14)
    // [mir] FakeRead(ForLet(None), _13)
    // [mir] StorageDead(_15)
    // [mir] StorageLive(_16)
    // [mir] StorageLive(_17)
    // [mir] StorageLive(_18)
    // [mir] _18 = &'?9 mut _2
    _18 := builtin$havoc_ref()
    inhale acc(_18.val_ref, write)
    _18.val_ref := mut borrow _2 // L4
    label l20
    // [mir] _17 = &'?10 mut (*_18)
    _17 := builtin$havoc_ref()
    inhale acc(_17.val_ref, write)
    _17.val_ref := mut borrow _18.val_ref // L5
    label l21
    // [mir] _16 = specialized::pclmulqdq::get(move _17) -> [return: bb7, unwind: bb63]
    label l22
    assert true
    assert (true) && (true)
    exhale (acc(_17.val_ref, write)) && ((acc(ref$Slice$u8(_17.val_ref), write)) && (true))
    _16 := builtin$havoc_ref()
    inhale (acc(ref$Slice$u8(old[l22](_17.val_ref)), write)) && (true)
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_16), write)
    inhale (true) && ((true) && (true))
    inhale true
    exhale true
    label l23
    Goto(cfg:15)
  label l24 // 15
    // ========== l24 ==========
    // MIR edge bb6 --> bb7
    // Expire borrows
    expire_borrows ReborrowingDAG(L26,L5,L4,)

    Goto(cfg:16)
  label bb7 // 16
    // ========== bb7 ==========
    __t7 := copy true
    // [mir] StorageDead(_17)
    // [mir] FakeRead(ForLet(None), _16)
    // [mir] StorageDead(_18)
    // [mir] StorageLive(_19)
    // [mir] StorageLive(_20)
    // [mir] StorageLive(_21)
    // [mir] _21 = &'?11 mut _2
    _21 := builtin$havoc_ref()
    inhale acc(_21.val_ref, write)
    _21.val_ref := mut borrow _2 // L6
    label l25
    // [mir] _20 = &'?12 mut (*_21)
    _20 := builtin$havoc_ref()
    inhale acc(_20.val_ref, write)
    _20.val_ref := mut borrow _21.val_ref // L7
    label l26
    // [mir] _19 = specialized::pclmulqdq::get(move _20) -> [return: bb8, unwind: bb63]
    label l27
    assert true
    assert (true) && (true)
    exhale (acc(_20.val_ref, write)) && ((acc(ref$Slice$u8(_20.val_ref), write)) && (true))
    _19 := builtin$havoc_ref()
    inhale (acc(ref$Slice$u8(old[l27](_20.val_ref)), write)) && (true)
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_19), write)
    inhale (true) && ((true) && (true))
    inhale true
    exhale true
    label l28
    Goto(cfg:17)
  label l29 // 17
    // ========== l29 ==========
    // MIR edge bb7 --> bb8
    // Expire borrows
    expire_borrows ReborrowingDAG(L23,L7,L6,)

    Goto(cfg:18)
  label bb8 // 18
    // ========== bb8 ==========
    __t8 := copy true
    // [mir] StorageDead(_20)
    // [mir] FakeRead(ForLet(None), _19)
    // [mir] StorageDead(_21)
    // [mir] StorageLive(_22)
    // [mir] StorageLive(_23)
    // [mir] _23 = _10
    _23 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_23), write)
    inhale (snap(_10)) == (snap(_23))
    label l30
    // [mir] StorageLive(_24)
    // [mir] StorageLive(_25)
    // [mir] StorageLive(_26)
    // [mir] StorageLive(_27)
    // [mir] _27 = _1
    _27 := builtin$havoc_ref()
    inhale acc(_27.val_int, write)
    _27.val_int := copy _1.val_int
    label l31
    // [mir] _26 = Not(move _27)
    _26 := builtin$havoc_ref()
    inhale acc(_26.val_int, write)
    _26.val_int := copy !(_27.val_int)
    // [mir] StorageDead(_27)
    // [mir] _25 = move _26 as i32 (IntToInt)
    _25 := builtin$havoc_ref()
    inhale acc(_25.val_int, write)
    _25.val_int := copy builtin$cast$u32$i32<>(_26.val_int)
    // [mir] StorageDead(_26)
    // [mir] _24 = std::arch::x86_64::_mm_cvtsi32_si128(move _25) -> [return: bb9, unwind: bb63]
    label l32
    assert true
    assert (true) && (true)
    exhale (acc(i32(_25), write)) && (true)
    _24 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_24), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l33
    Goto(cfg:19)
  label bb9 // 19
    // ========== bb9 ==========
    __t9 := copy true
    // [mir] StorageDead(_25)
    // [mir] _22 = std::arch::x86_64::_mm_xor_si128(move _23, move _24) -> [return: bb10, unwind: bb63]
    label l34
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_23), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_24), write)) && (true))
    _22 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_22), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l35
    Goto(cfg:20)
  label bb10 // 20
    // ========== bb10 ==========
    __t10 := copy true
    // [mir] StorageDead(_24)
    // [mir] StorageDead(_23)
    // [mir] _10 = move _22
    _10 := move _22
    label l36
    // [mir] StorageDead(_22)
    // [mir] StorageLive(_28)
    // [mir] _28 = std::arch::x86_64::_mm_set_epi64x(const _, const _) -> [return: bb11, unwind: bb63]
    label l37
    _t135 := builtin$havoc_ref()
    inhale acc(i64(_t135), write)
    _t136 := builtin$havoc_ref()
    inhale acc(i64(_t136), write)
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(i64(_t135), write)) && ((acc(i64(_t136), write)) && (true))
    _28 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_28), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l38
    Goto(cfg:21)
  label bb11 // 21
    // ========== bb11 ==========
    __t11 := copy true
    // [mir] FakeRead(ForLet(None), _28)
    // [mir] StorageLive(_29)
    // [mir] goto -> bb12
    Goto(cfg:22)
  label loop12_start // 22
    // ========== loop12_start ==========
    Goto(cfg:23)
  label loop12_group1_bb12 // 23
    // ========== loop12_group1_bb12 ==========
    // This is a loop head
    __t12 := copy true
    // [mir] falseUnwind -> [real: bb13, unwind: bb63]
    Goto(cfg:24)
  label loop12_group1_bb13 // 24
    // ========== loop12_group1_bb13 ==========
    __t13 := copy true
    // [mir] StorageLive(_31)
    // [mir] StorageLive(_32)
    // [mir] StorageLive(_33)
    // [mir] _33 = &'?13 (*_2)
    _33 := builtin$havoc_ref()
    inhale acc(_33.val_ref, write)
    _33.val_ref := borrow _2.val_ref // L24
    label l39
    // [mir] _32 = core::slice::<impl [u8]>::len(move _33) -> [return: bb14, unwind: bb63]
    label l40
    _32 := builtin$havoc_ref()
    inhale acc(_32.val_int, write)
    _32.val_int := copy Slice$len<Ref(u8)>(_33.val_ref)
    transfer perm _33.val_ref --> old[l40](_33.val_ref) // unchecked: false
    Goto(cfg:25)
  label l41 // 25
    // ========== l41 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    expire_borrows ReborrowingDAG(L41,L24,)

    Goto(cfg:26)
  label loop12_group1_bb14 // 26
    // ========== loop12_group1_bb14 ==========
    __t14 := copy true
    // [mir] StorageDead(_33)
    // [mir] _31 = Ge(move _32, const 64_usize)
    _31 := builtin$havoc_ref()
    inhale acc(_31.val_bool, write)
    _31.val_bool := copy (_32.val_int) >= (64)
    // [mir] switchInt(move _31) -> [0: bb24, otherwise: bb15]
    __t64 := copy _31.val_bool
    GotoSwitch([(Local(Local { variable: __t64: Bool, position: Position { line: 0, column: 0, id: 0 } }), cfg:28)], cfg:27)
  label l42 // 27
    // ========== l42 ==========
    // MIR edge bb14 --> bb24
    Goto(cfg:58)
  label l43 // 28
    // ========== l43 ==========
    // MIR edge bb14 --> bb15
    Goto(cfg:29)
  label loop12_inv_pre // 29
    // ========== loop12_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb12)
    _preserve$0 := ghost _2.val_ref
    obtain acc(usize(_32), write)
    obtain acc(struct$m_std$$arch$$x86_64$$__m128i(_10), write)
    obtain acc(struct$m_std$$arch$$x86_64$$__m128i(_13), write)
    obtain acc(struct$m_std$$arch$$x86_64$$__m128i(_16), write)
    obtain acc(struct$m_std$$arch$$x86_64$$__m128i(_19), write)
    obtain acc(_2.val_ref, write)
    obtain acc(struct$m_std$$arch$$x86_64$$__m128i(_28), read)
    assert true
    assert (true) && ((true) && ((true) && ((true) && ((true) && ((true) && (true))))))
    assert ((_preserve$0) == (_2.val_ref)) && (true)
    exhale (acc(usize(_32), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_10), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_13), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_16), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_19), write)) && ((acc(_2.val_ref, write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_28), read)) && (true)))))))
    _10 := builtin$havoc_ref()
    _13 := builtin$havoc_ref()
    _16 := builtin$havoc_ref()
    _19 := builtin$havoc_ref()
    _31 := builtin$havoc_ref()
    _32 := builtin$havoc_ref()
    _33 := builtin$havoc_ref()
    _34 := builtin$havoc_ref()
    _35 := builtin$havoc_ref()
    _36 := builtin$havoc_ref()
    _37 := builtin$havoc_ref()
    _38 := builtin$havoc_ref()
    _39 := builtin$havoc_ref()
    _40 := builtin$havoc_ref()
    _41 := builtin$havoc_ref()
    _42 := builtin$havoc_ref()
    _43 := builtin$havoc_ref()
    _44 := builtin$havoc_ref()
    _45 := builtin$havoc_ref()
    _46 := builtin$havoc_ref()
    _47 := builtin$havoc_ref()
    _48 := builtin$havoc_ref()
    _49 := builtin$havoc_ref()
    _50 := builtin$havoc_ref()
    _51 := builtin$havoc_ref()
    _52 := builtin$havoc_ref()
    _53 := builtin$havoc_ref()
    _54 := builtin$havoc_ref()
    _55 := builtin$havoc_ref()
    _56 := builtin$havoc_ref()
    _57 := builtin$havoc_ref()
    __t12 := builtin$havoc_bool()
    __t13 := builtin$havoc_bool()
    __t14 := builtin$havoc_bool()
    __t15 := builtin$havoc_bool()
    __t16 := builtin$havoc_bool()
    __t17 := builtin$havoc_bool()
    __t18 := builtin$havoc_bool()
    __t19 := builtin$havoc_bool()
    __t20 := builtin$havoc_bool()
    __t21 := builtin$havoc_bool()
    __t22 := builtin$havoc_bool()
    __t23 := builtin$havoc_bool()
    __t65 := builtin$havoc_bool()
    __t66 := builtin$havoc_bool()
    Goto(cfg:30)
  label loop12_inv_post_perm // 30
    // ========== loop12_inv_post_perm ==========
    // Inhale the loop permissions invariant of block bb12
    inhale (acc(usize(_32), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_10), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_13), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_16), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_19), write)) && ((acc(_2.val_ref, write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_28), read)) && (true)))))))
    inhale ((_preserve$0) == (_2.val_ref)) && (true)
    inhale (true) && ((true) && ((true) && ((true) && ((true) && ((true) && (true))))))
    Goto(cfg:32)
  label loop12_inv_post_fnspc // 31
    // ========== loop12_inv_post_fnspc ==========
    // Inhale the loop fnspec invariant of block bb12
    inhale true
    Goto(cfg:38)
  label loop12_group2a_bb12 // 32
    // ========== loop12_group2a_bb12 ==========
    // This is a loop head
    __t12 := copy true
    // [mir] falseUnwind -> [real: bb13, unwind: bb63]
    Goto(cfg:33)
  label loop12_group2a_bb13 // 33
    // ========== loop12_group2a_bb13 ==========
    __t13 := copy true
    // [mir] StorageLive(_31)
    // [mir] StorageLive(_32)
    // [mir] StorageLive(_33)
    // [mir] _33 = &'?13 (*_2)
    _33 := builtin$havoc_ref()
    inhale acc(_33.val_ref, write)
    _33.val_ref := borrow _2.val_ref // L24
    label l44
    // [mir] _32 = core::slice::<impl [u8]>::len(move _33) -> [return: bb14, unwind: bb63]
    label l45
    _32 := builtin$havoc_ref()
    inhale acc(_32.val_int, write)
    _32.val_int := copy Slice$len<Ref(u8)>(_33.val_ref)
    transfer perm _33.val_ref --> old[l45](_33.val_ref) // unchecked: false
    Goto(cfg:34)
  label l46 // 34
    // ========== l46 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    expire_borrows ReborrowingDAG(L41,L24,)

    Goto(cfg:35)
  label loop12_group2a_bb14 // 35
    // ========== loop12_group2a_bb14 ==========
    __t14 := copy true
    // [mir] StorageDead(_33)
    // [mir] _31 = Ge(move _32, const 64_usize)
    _31 := builtin$havoc_ref()
    inhale acc(_31.val_bool, write)
    _31.val_bool := copy (_32.val_int) >= (64)
    // [mir] switchInt(move _31) -> [0: bb24, otherwise: bb15]
    __t65 := copy _31.val_bool
    GotoSwitch([(Local(Local { variable: __t65: Bool, position: Position { line: 0, column: 0, id: 0 } }), cfg:37)], cfg:36)
  label l47 // 36
    // ========== l47 ==========
    // MIR edge bb14 --> bb24
    Return
  label l48 // 37
    // ========== l48 ==========
    // MIR edge bb14 --> bb15
    Goto(cfg:31)
  label loop12_group3_bb15 // 38
    // ========== loop12_group3_bb15 ==========
    __t15 := copy true
    // [mir] StorageDead(_32)
    // [mir] StorageLive(_34)
    // [mir] StorageLive(_35)
    // [mir] _35 = _10
    _35 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_35), write)
    inhale (snap(_10)) == (snap(_35))
    label l49
    // [mir] StorageLive(_36)
    // [mir] StorageLive(_37)
    // [mir] StorageLive(_38)
    // [mir] _38 = &'?14 mut _2
    _38 := builtin$havoc_ref()
    inhale acc(_38.val_ref, write)
    _38.val_ref := mut borrow _2 // L8
    label l50
    // [mir] _37 = &'?15 mut (*_38)
    _37 := builtin$havoc_ref()
    inhale acc(_37.val_ref, write)
    _37.val_ref := mut borrow _38.val_ref // L9
    label l51
    // [mir] _36 = specialized::pclmulqdq::get(move _37) -> [return: bb16, unwind: bb63]
    label l52
    assert true
    assert (true) && (true)
    exhale (acc(_37.val_ref, write)) && ((acc(ref$Slice$u8(_37.val_ref), write)) && (true))
    _36 := builtin$havoc_ref()
    inhale (acc(ref$Slice$u8(old[l52](_37.val_ref)), write)) && (true)
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_36), write)
    inhale (true) && ((true) && (true))
    inhale true
    exhale true
    label l53
    Goto(cfg:39)
  label l54 // 39
    // ========== l54 ==========
    // MIR edge bb15 --> bb16
    // Expire borrows
    expire_borrows ReborrowingDAG(L29,L9,L8,)

    Goto(cfg:40)
  label loop12_group3_bb16 // 40
    // ========== loop12_group3_bb16 ==========
    __t16 := copy true
    // [mir] StorageDead(_37)
    // [mir] StorageLive(_39)
    // [mir] _39 = _28
    _39 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_39), write)
    inhale (snap(_28)) == (snap(_39))
    label l55
    // [mir] _34 = specialized::pclmulqdq::reduce128(move _35, move _36, move _39) -> [return: bb17, unwind: bb63]
    label l56
    assert true
    assert (true) && ((true) && ((true) && (true)))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_35), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_36), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_39), write)) && (true)))
    _34 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_34), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l57
    Goto(cfg:41)
  label loop12_group3_bb17 // 41
    // ========== loop12_group3_bb17 ==========
    __t17 := copy true
    // [mir] StorageDead(_39)
    // [mir] StorageDead(_36)
    // [mir] StorageDead(_35)
    // [mir] _10 = move _34
    _10 := move _34
    label l58
    // [mir] StorageDead(_34)
    // [mir] StorageDead(_38)
    // [mir] StorageLive(_40)
    // [mir] StorageLive(_41)
    // [mir] _41 = _13
    _41 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_41), write)
    inhale (snap(_13)) == (snap(_41))
    label l59
    // [mir] StorageLive(_42)
    // [mir] StorageLive(_43)
    // [mir] StorageLive(_44)
    // [mir] _44 = &'?16 mut _2
    _44 := builtin$havoc_ref()
    inhale acc(_44.val_ref, write)
    _44.val_ref := mut borrow _2 // L10
    label l60
    // [mir] _43 = &'?17 mut (*_44)
    _43 := builtin$havoc_ref()
    inhale acc(_43.val_ref, write)
    _43.val_ref := mut borrow _44.val_ref // L11
    label l61
    // [mir] _42 = specialized::pclmulqdq::get(move _43) -> [return: bb18, unwind: bb63]
    label l62
    assert true
    assert (true) && (true)
    exhale (acc(_43.val_ref, write)) && ((acc(ref$Slice$u8(_43.val_ref), write)) && (true))
    _42 := builtin$havoc_ref()
    inhale (acc(ref$Slice$u8(old[l62](_43.val_ref)), write)) && (true)
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_42), write)
    inhale (true) && ((true) && (true))
    inhale true
    exhale true
    label l63
    Goto(cfg:42)
  label l64 // 42
    // ========== l64 ==========
    // MIR edge bb17 --> bb18
    // Expire borrows
    expire_borrows ReborrowingDAG(L42,L11,L10,)

    Goto(cfg:43)
  label loop12_group3_bb18 // 43
    // ========== loop12_group3_bb18 ==========
    __t18 := copy true
    // [mir] StorageDead(_43)
    // [mir] StorageLive(_45)
    // [mir] _45 = _28
    _45 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_45), write)
    inhale (snap(_28)) == (snap(_45))
    label l65
    // [mir] _40 = specialized::pclmulqdq::reduce128(move _41, move _42, move _45) -> [return: bb19, unwind: bb63]
    label l66
    assert true
    assert (true) && ((true) && ((true) && (true)))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_41), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_42), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_45), write)) && (true)))
    _40 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_40), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l67
    Goto(cfg:44)
  label loop12_group3_bb19 // 44
    // ========== loop12_group3_bb19 ==========
    __t19 := copy true
    // [mir] StorageDead(_45)
    // [mir] StorageDead(_42)
    // [mir] StorageDead(_41)
    // [mir] _13 = move _40
    _13 := move _40
    label l68
    // [mir] StorageDead(_40)
    // [mir] StorageDead(_44)
    // [mir] StorageLive(_46)
    // [mir] StorageLive(_47)
    // [mir] _47 = _16
    _47 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_47), write)
    inhale (snap(_16)) == (snap(_47))
    label l69
    // [mir] StorageLive(_48)
    // [mir] StorageLive(_49)
    // [mir] StorageLive(_50)
    // [mir] _50 = &'?18 mut _2
    _50 := builtin$havoc_ref()
    inhale acc(_50.val_ref, write)
    _50.val_ref := mut borrow _2 // L12
    label l70
    // [mir] _49 = &'?19 mut (*_50)
    _49 := builtin$havoc_ref()
    inhale acc(_49.val_ref, write)
    _49.val_ref := mut borrow _50.val_ref // L13
    label l71
    // [mir] _48 = specialized::pclmulqdq::get(move _49) -> [return: bb20, unwind: bb63]
    label l72
    assert true
    assert (true) && (true)
    exhale (acc(_49.val_ref, write)) && ((acc(ref$Slice$u8(_49.val_ref), write)) && (true))
    _48 := builtin$havoc_ref()
    inhale (acc(ref$Slice$u8(old[l72](_49.val_ref)), write)) && (true)
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_48), write)
    inhale (true) && ((true) && (true))
    inhale true
    exhale true
    label l73
    Goto(cfg:45)
  label l74 // 45
    // ========== l74 ==========
    // MIR edge bb19 --> bb20
    // Expire borrows
    expire_borrows ReborrowingDAG(L27,L13,L12,)

    Goto(cfg:46)
  label loop12_group3_bb20 // 46
    // ========== loop12_group3_bb20 ==========
    __t20 := copy true
    // [mir] StorageDead(_49)
    // [mir] StorageLive(_51)
    // [mir] _51 = _28
    _51 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_51), write)
    inhale (snap(_28)) == (snap(_51))
    label l75
    // [mir] _46 = specialized::pclmulqdq::reduce128(move _47, move _48, move _51) -> [return: bb21, unwind: bb63]
    label l76
    assert true
    assert (true) && ((true) && ((true) && (true)))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_47), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_48), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_51), write)) && (true)))
    _46 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_46), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l77
    Goto(cfg:47)
  label loop12_group3_bb21 // 47
    // ========== loop12_group3_bb21 ==========
    __t21 := copy true
    // [mir] StorageDead(_51)
    // [mir] StorageDead(_48)
    // [mir] StorageDead(_47)
    // [mir] _16 = move _46
    _16 := move _46
    label l78
    // [mir] StorageDead(_46)
    // [mir] StorageDead(_50)
    // [mir] StorageLive(_52)
    // [mir] StorageLive(_53)
    // [mir] _53 = _19
    _53 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_53), write)
    inhale (snap(_19)) == (snap(_53))
    label l79
    // [mir] StorageLive(_54)
    // [mir] StorageLive(_55)
    // [mir] StorageLive(_56)
    // [mir] _56 = &'?20 mut _2
    _56 := builtin$havoc_ref()
    inhale acc(_56.val_ref, write)
    _56.val_ref := mut borrow _2 // L14
    label l80
    // [mir] _55 = &'?21 mut (*_56)
    _55 := builtin$havoc_ref()
    inhale acc(_55.val_ref, write)
    _55.val_ref := mut borrow _56.val_ref // L15
    label l81
    // [mir] _54 = specialized::pclmulqdq::get(move _55) -> [return: bb22, unwind: bb63]
    label l82
    assert true
    assert (true) && (true)
    exhale (acc(_55.val_ref, write)) && ((acc(ref$Slice$u8(_55.val_ref), write)) && (true))
    _54 := builtin$havoc_ref()
    inhale (acc(ref$Slice$u8(old[l82](_55.val_ref)), write)) && (true)
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_54), write)
    inhale (true) && ((true) && (true))
    inhale true
    exhale true
    label l83
    Goto(cfg:48)
  label l84 // 48
    // ========== l84 ==========
    // MIR edge bb21 --> bb22
    // Expire borrows
    expire_borrows ReborrowingDAG(L39,L15,L14,)

    Goto(cfg:49)
  label loop12_group3_bb22 // 49
    // ========== loop12_group3_bb22 ==========
    __t22 := copy true
    // [mir] StorageDead(_55)
    // [mir] StorageLive(_57)
    // [mir] _57 = _28
    _57 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_57), write)
    inhale (snap(_28)) == (snap(_57))
    label l85
    // [mir] _52 = specialized::pclmulqdq::reduce128(move _53, move _54, move _57) -> [return: bb23, unwind: bb63]
    label l86
    assert true
    assert (true) && ((true) && ((true) && (true)))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_53), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_54), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_57), write)) && (true)))
    _52 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_52), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l87
    Goto(cfg:50)
  label loop12_group3_bb23 // 50
    // ========== loop12_group3_bb23 ==========
    __t23 := copy true
    // [mir] StorageDead(_57)
    // [mir] StorageDead(_54)
    // [mir] StorageDead(_53)
    // [mir] _19 = move _52
    _19 := move _52
    label l88
    // [mir] StorageDead(_52)
    // [mir] StorageDead(_56)
    // [mir] _30 = const ()
    // [mir] StorageDead(_31)
    // [mir] goto -> bb12
    Goto(cfg:51)
  label loop12_group4_bb12 // 51
    // ========== loop12_group4_bb12 ==========
    // This is a loop head
    __t12 := copy true
    // [mir] falseUnwind -> [real: bb13, unwind: bb63]
    Goto(cfg:52)
  label loop12_group4_bb13 // 52
    // ========== loop12_group4_bb13 ==========
    __t13 := copy true
    // [mir] StorageLive(_31)
    // [mir] StorageLive(_32)
    // [mir] StorageLive(_33)
    // [mir] _33 = &'?13 (*_2)
    _33 := builtin$havoc_ref()
    inhale acc(_33.val_ref, write)
    _33.val_ref := borrow _2.val_ref // L24
    label l89
    // [mir] _32 = core::slice::<impl [u8]>::len(move _33) -> [return: bb14, unwind: bb63]
    label l90
    _32 := builtin$havoc_ref()
    inhale acc(_32.val_int, write)
    _32.val_int := copy Slice$len<Ref(u8)>(_33.val_ref)
    transfer perm _33.val_ref --> old[l90](_33.val_ref) // unchecked: false
    Goto(cfg:53)
  label l91 // 53
    // ========== l91 ==========
    // MIR edge bb13 --> bb14
    // Expire borrows
    expire_borrows ReborrowingDAG(L41,L24,)

    Goto(cfg:54)
  label loop12_group4_bb14 // 54
    // ========== loop12_group4_bb14 ==========
    __t14 := copy true
    // [mir] StorageDead(_33)
    // [mir] _31 = Ge(move _32, const 64_usize)
    _31 := builtin$havoc_ref()
    inhale acc(_31.val_bool, write)
    _31.val_bool := copy (_32.val_int) >= (64)
    // [mir] switchInt(move _31) -> [0: bb24, otherwise: bb15]
    __t66 := copy _31.val_bool
    GotoSwitch([(Local(Local { variable: __t66: Bool, position: Position { line: 0, column: 0, id: 0 } }), cfg:56)], cfg:55)
  label l92 // 55
    // ========== l92 ==========
    // MIR edge bb14 --> bb24
    Goto(cfg:58)
  label l93 // 56
    // ========== l93 ==========
    // MIR edge bb14 --> bb15
    Goto(cfg:57)
  label loop12_end_body // 57
    // ========== loop12_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb12)
    obtain acc(usize(_32), write)
    obtain acc(struct$m_std$$arch$$x86_64$$__m128i(_10), write)
    obtain acc(struct$m_std$$arch$$x86_64$$__m128i(_13), write)
    obtain acc(struct$m_std$$arch$$x86_64$$__m128i(_16), write)
    obtain acc(struct$m_std$$arch$$x86_64$$__m128i(_19), write)
    obtain acc(_2.val_ref, write)
    obtain acc(struct$m_std$$arch$$x86_64$$__m128i(_28), read)
    assert true
    assert (true) && ((true) && ((true) && ((true) && ((true) && ((true) && (true))))))
    assert ((_preserve$0) == (_2.val_ref)) && (true)
    exhale (acc(usize(_32), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_10), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_13), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_16), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_19), write)) && ((acc(_2.val_ref, write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_28), read)) && (true)))))))
    inhale false
    Return
  label bb24 // 58
    // ========== bb24 ==========
    __t24 := copy true
    // [mir] StorageDead(_32)
    // [mir] StorageLive(_59)
    // [mir] _29 = const ()
    // [mir] StorageDead(_59)
    // [mir] StorageDead(_31)
    // [mir] StorageDead(_29)
    // [mir] StorageLive(_61)
    // [mir] _61 = std::arch::x86_64::_mm_set_epi64x(const _, const _) -> [return: bb25, unwind: bb63]
    label l94
    _t137 := builtin$havoc_ref()
    inhale acc(i64(_t137), write)
    _t138 := builtin$havoc_ref()
    inhale acc(i64(_t138), write)
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(i64(_t137), write)) && ((acc(i64(_t138), write)) && (true))
    _61 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_61), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l95
    Goto(cfg:59)
  label bb25 // 59
    // ========== bb25 ==========
    __t25 := copy true
    // [mir] FakeRead(ForLet(None), _61)
    // [mir] StorageLive(_62)
    // [mir] StorageLive(_63)
    // [mir] _63 = _10
    _63 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_63), write)
    inhale (snap(_10)) == (snap(_63))
    label l96
    // [mir] StorageLive(_64)
    // [mir] _64 = _13
    _64 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_64), write)
    inhale (snap(_13)) == (snap(_64))
    label l97
    // [mir] StorageLive(_65)
    // [mir] _65 = _61
    _65 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_65), write)
    inhale (snap(_61)) == (snap(_65))
    label l98
    // [mir] _62 = specialized::pclmulqdq::reduce128(move _63, move _64, move _65) -> [return: bb26, unwind: bb63]
    label l99
    assert true
    assert (true) && ((true) && ((true) && (true)))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_63), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_64), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_65), write)) && (true)))
    _62 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_62), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l100
    Goto(cfg:60)
  label bb26 // 60
    // ========== bb26 ==========
    __t26 := copy true
    // [mir] StorageDead(_65)
    // [mir] StorageDead(_64)
    // [mir] StorageDead(_63)
    // [mir] FakeRead(ForLet(None), _62)
    // [mir] StorageLive(_66)
    // [mir] StorageLive(_67)
    // [mir] _67 = _62
    _67 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_67), write)
    inhale (snap(_62)) == (snap(_67))
    label l101
    // [mir] StorageLive(_68)
    // [mir] _68 = _16
    _68 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_68), write)
    inhale (snap(_16)) == (snap(_68))
    label l102
    // [mir] StorageLive(_69)
    // [mir] _69 = _61
    _69 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_69), write)
    inhale (snap(_61)) == (snap(_69))
    label l103
    // [mir] _66 = specialized::pclmulqdq::reduce128(move _67, move _68, move _69) -> [return: bb27, unwind: bb63]
    label l104
    assert true
    assert (true) && ((true) && ((true) && (true)))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_67), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_68), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_69), write)) && (true)))
    _66 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_66), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l105
    Goto(cfg:61)
  label bb27 // 61
    // ========== bb27 ==========
    __t27 := copy true
    // [mir] StorageDead(_69)
    // [mir] StorageDead(_68)
    // [mir] StorageDead(_67)
    // [mir] _62 = move _66
    _62 := move _66
    label l106
    // [mir] StorageDead(_66)
    // [mir] StorageLive(_70)
    // [mir] StorageLive(_71)
    // [mir] _71 = _62
    _71 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_71), write)
    inhale (snap(_62)) == (snap(_71))
    label l107
    // [mir] StorageLive(_72)
    // [mir] _72 = _19
    _72 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_72), write)
    inhale (snap(_19)) == (snap(_72))
    label l108
    // [mir] StorageLive(_73)
    // [mir] _73 = _61
    _73 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_73), write)
    inhale (snap(_61)) == (snap(_73))
    label l109
    // [mir] _70 = specialized::pclmulqdq::reduce128(move _71, move _72, move _73) -> [return: bb28, unwind: bb63]
    label l110
    assert true
    assert (true) && ((true) && ((true) && (true)))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_71), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_72), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_73), write)) && (true)))
    _70 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_70), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l111
    Goto(cfg:62)
  label bb28 // 62
    // ========== bb28 ==========
    __t28 := copy true
    // [mir] StorageDead(_73)
    // [mir] StorageDead(_72)
    // [mir] StorageDead(_71)
    // [mir] _62 = move _70
    _62 := move _70
    label l112
    // [mir] StorageDead(_70)
    // [mir] StorageLive(_74)
    // [mir] goto -> bb29
    Goto(cfg:63)
  label loop29_start // 63
    // ========== loop29_start ==========
    Goto(cfg:64)
  label loop29_group1_bb29 // 64
    // ========== loop29_group1_bb29 ==========
    // This is a loop head
    __t29 := copy true
    // [mir] falseUnwind -> [real: bb30, unwind: bb63]
    Goto(cfg:65)
  label loop29_group1_bb30 // 65
    // ========== loop29_group1_bb30 ==========
    __t30 := copy true
    // [mir] StorageLive(_75)
    // [mir] StorageLive(_76)
    // [mir] StorageLive(_77)
    // [mir] _77 = &'?22 (*_2)
    _77 := builtin$havoc_ref()
    inhale acc(_77.val_ref, write)
    _77.val_ref := borrow _2.val_ref // L38
    label l113
    // [mir] _76 = core::slice::<impl [u8]>::len(move _77) -> [return: bb31, unwind: bb63]
    label l114
    _76 := builtin$havoc_ref()
    inhale acc(_76.val_int, write)
    _76.val_int := copy Slice$len<Ref(u8)>(_77.val_ref)
    transfer perm _77.val_ref --> old[l114](_77.val_ref) // unchecked: false
    Goto(cfg:66)
  label l115 // 66
    // ========== l115 ==========
    // MIR edge bb30 --> bb31
    // Expire borrows
    expire_borrows ReborrowingDAG(L30,L38,)

    Goto(cfg:67)
  label loop29_group1_bb31 // 67
    // ========== loop29_group1_bb31 ==========
    __t31 := copy true
    // [mir] StorageDead(_77)
    // [mir] _75 = Ge(move _76, const 16_usize)
    _75 := builtin$havoc_ref()
    inhale acc(_75.val_bool, write)
    _75.val_bool := copy (_76.val_int) >= (16)
    // [mir] switchInt(move _75) -> [0: bb35, otherwise: bb32]
    __t67 := copy _75.val_bool
    GotoSwitch([(Local(Local { variable: __t67: Bool, position: Position { line: 0, column: 0, id: 0 } }), cfg:69)], cfg:68)
  label l116 // 68
    // ========== l116 ==========
    // MIR edge bb31 --> bb35
    Goto(cfg:90)
  label l117 // 69
    // ========== l117 ==========
    // MIR edge bb31 --> bb32
    Goto(cfg:70)
  label loop29_inv_pre // 70
    // ========== loop29_inv_pre ==========
    // Assert and exhale the loop body invariant (loop head: bb29)
    _preserve$1 := ghost _2.val_ref
    obtain acc(usize(_76), write)
    obtain acc(struct$m_std$$arch$$x86_64$$__m128i(_62), write)
    obtain acc(_2.val_ref, write)
    obtain acc(struct$m_std$$arch$$x86_64$$__m128i(_61), read)
    assert true
    assert (true) && ((true) && ((true) && (true)))
    assert ((_preserve$1) == (_2.val_ref)) && (true)
    exhale (acc(usize(_76), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_62), write)) && ((acc(_2.val_ref, write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_61), read)) && (true))))
    _62 := builtin$havoc_ref()
    _75 := builtin$havoc_ref()
    _76 := builtin$havoc_ref()
    _77 := builtin$havoc_ref()
    _78 := builtin$havoc_ref()
    _79 := builtin$havoc_ref()
    _80 := builtin$havoc_ref()
    _81 := builtin$havoc_ref()
    _82 := builtin$havoc_ref()
    _83 := builtin$havoc_ref()
    __t29 := builtin$havoc_bool()
    __t30 := builtin$havoc_bool()
    __t31 := builtin$havoc_bool()
    __t32 := builtin$havoc_bool()
    __t33 := builtin$havoc_bool()
    __t34 := builtin$havoc_bool()
    __t68 := builtin$havoc_bool()
    __t69 := builtin$havoc_bool()
    Goto(cfg:71)
  label loop29_inv_post_perm // 71
    // ========== loop29_inv_post_perm ==========
    // Inhale the loop permissions invariant of block bb29
    inhale (acc(usize(_76), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_62), write)) && ((acc(_2.val_ref, write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_61), read)) && (true))))
    inhale ((_preserve$1) == (_2.val_ref)) && (true)
    inhale (true) && ((true) && ((true) && (true)))
    Goto(cfg:73)
  label loop29_inv_post_fnspc // 72
    // ========== loop29_inv_post_fnspc ==========
    // Inhale the loop fnspec invariant of block bb29
    inhale true
    Goto(cfg:79)
  label loop29_group2a_bb29 // 73
    // ========== loop29_group2a_bb29 ==========
    // This is a loop head
    __t29 := copy true
    // [mir] falseUnwind -> [real: bb30, unwind: bb63]
    Goto(cfg:74)
  label loop29_group2a_bb30 // 74
    // ========== loop29_group2a_bb30 ==========
    __t30 := copy true
    // [mir] StorageLive(_75)
    // [mir] StorageLive(_76)
    // [mir] StorageLive(_77)
    // [mir] _77 = &'?22 (*_2)
    _77 := builtin$havoc_ref()
    inhale acc(_77.val_ref, write)
    _77.val_ref := borrow _2.val_ref // L38
    label l118
    // [mir] _76 = core::slice::<impl [u8]>::len(move _77) -> [return: bb31, unwind: bb63]
    label l119
    _76 := builtin$havoc_ref()
    inhale acc(_76.val_int, write)
    _76.val_int := copy Slice$len<Ref(u8)>(_77.val_ref)
    transfer perm _77.val_ref --> old[l119](_77.val_ref) // unchecked: false
    Goto(cfg:75)
  label l120 // 75
    // ========== l120 ==========
    // MIR edge bb30 --> bb31
    // Expire borrows
    expire_borrows ReborrowingDAG(L30,L38,)

    Goto(cfg:76)
  label loop29_group2a_bb31 // 76
    // ========== loop29_group2a_bb31 ==========
    __t31 := copy true
    // [mir] StorageDead(_77)
    // [mir] _75 = Ge(move _76, const 16_usize)
    _75 := builtin$havoc_ref()
    inhale acc(_75.val_bool, write)
    _75.val_bool := copy (_76.val_int) >= (16)
    // [mir] switchInt(move _75) -> [0: bb35, otherwise: bb32]
    __t68 := copy _75.val_bool
    GotoSwitch([(Local(Local { variable: __t68: Bool, position: Position { line: 0, column: 0, id: 0 } }), cfg:78)], cfg:77)
  label l121 // 77
    // ========== l121 ==========
    // MIR edge bb31 --> bb35
    Return
  label l122 // 78
    // ========== l122 ==========
    // MIR edge bb31 --> bb32
    Goto(cfg:72)
  label loop29_group3_bb32 // 79
    // ========== loop29_group3_bb32 ==========
    __t32 := copy true
    // [mir] StorageDead(_76)
    // [mir] StorageLive(_78)
    // [mir] StorageLive(_79)
    // [mir] _79 = _62
    _79 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_79), write)
    inhale (snap(_62)) == (snap(_79))
    label l123
    // [mir] StorageLive(_80)
    // [mir] StorageLive(_81)
    // [mir] StorageLive(_82)
    // [mir] _82 = &'?23 mut _2
    _82 := builtin$havoc_ref()
    inhale acc(_82.val_ref, write)
    _82.val_ref := mut borrow _2 // L16
    label l124
    // [mir] _81 = &'?24 mut (*_82)
    _81 := builtin$havoc_ref()
    inhale acc(_81.val_ref, write)
    _81.val_ref := mut borrow _82.val_ref // L17
    label l125
    // [mir] _80 = specialized::pclmulqdq::get(move _81) -> [return: bb33, unwind: bb63]
    label l126
    assert true
    assert (true) && (true)
    exhale (acc(_81.val_ref, write)) && ((acc(ref$Slice$u8(_81.val_ref), write)) && (true))
    _80 := builtin$havoc_ref()
    inhale (acc(ref$Slice$u8(old[l126](_81.val_ref)), write)) && (true)
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_80), write)
    inhale (true) && ((true) && (true))
    inhale true
    exhale true
    label l127
    Goto(cfg:80)
  label l128 // 80
    // ========== l128 ==========
    // MIR edge bb32 --> bb33
    // Expire borrows
    expire_borrows ReborrowingDAG(L43,L17,L16,)

    Goto(cfg:81)
  label loop29_group3_bb33 // 81
    // ========== loop29_group3_bb33 ==========
    __t33 := copy true
    // [mir] StorageDead(_81)
    // [mir] StorageLive(_83)
    // [mir] _83 = _61
    _83 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_83), write)
    inhale (snap(_61)) == (snap(_83))
    label l129
    // [mir] _78 = specialized::pclmulqdq::reduce128(move _79, move _80, move _83) -> [return: bb34, unwind: bb63]
    label l130
    assert true
    assert (true) && ((true) && ((true) && (true)))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_79), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_80), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_83), write)) && (true)))
    _78 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_78), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l131
    Goto(cfg:82)
  label loop29_group3_bb34 // 82
    // ========== loop29_group3_bb34 ==========
    __t34 := copy true
    // [mir] StorageDead(_83)
    // [mir] StorageDead(_80)
    // [mir] StorageDead(_79)
    // [mir] _62 = move _78
    _62 := move _78
    label l132
    // [mir] StorageDead(_78)
    // [mir] StorageDead(_82)
    // [mir] _30 = const ()
    // [mir] StorageDead(_75)
    // [mir] goto -> bb29
    Goto(cfg:83)
  label loop29_group4_bb29 // 83
    // ========== loop29_group4_bb29 ==========
    // This is a loop head
    __t29 := copy true
    // [mir] falseUnwind -> [real: bb30, unwind: bb63]
    Goto(cfg:84)
  label loop29_group4_bb30 // 84
    // ========== loop29_group4_bb30 ==========
    __t30 := copy true
    // [mir] StorageLive(_75)
    // [mir] StorageLive(_76)
    // [mir] StorageLive(_77)
    // [mir] _77 = &'?22 (*_2)
    _77 := builtin$havoc_ref()
    inhale acc(_77.val_ref, write)
    _77.val_ref := borrow _2.val_ref // L38
    label l133
    // [mir] _76 = core::slice::<impl [u8]>::len(move _77) -> [return: bb31, unwind: bb63]
    label l134
    _76 := builtin$havoc_ref()
    inhale acc(_76.val_int, write)
    _76.val_int := copy Slice$len<Ref(u8)>(_77.val_ref)
    transfer perm _77.val_ref --> old[l134](_77.val_ref) // unchecked: false
    Goto(cfg:85)
  label l135 // 85
    // ========== l135 ==========
    // MIR edge bb30 --> bb31
    // Expire borrows
    expire_borrows ReborrowingDAG(L30,L38,)

    Goto(cfg:86)
  label loop29_group4_bb31 // 86
    // ========== loop29_group4_bb31 ==========
    __t31 := copy true
    // [mir] StorageDead(_77)
    // [mir] _75 = Ge(move _76, const 16_usize)
    _75 := builtin$havoc_ref()
    inhale acc(_75.val_bool, write)
    _75.val_bool := copy (_76.val_int) >= (16)
    // [mir] switchInt(move _75) -> [0: bb35, otherwise: bb32]
    __t69 := copy _75.val_bool
    GotoSwitch([(Local(Local { variable: __t69: Bool, position: Position { line: 0, column: 0, id: 0 } }), cfg:88)], cfg:87)
  label l136 // 87
    // ========== l136 ==========
    // MIR edge bb31 --> bb35
    Goto(cfg:90)
  label l137 // 88
    // ========== l137 ==========
    // MIR edge bb31 --> bb32
    Goto(cfg:89)
  label loop29_end_body // 89
    // ========== loop29_end_body ==========
    // Assert and exhale the loop body invariant (loop head: bb29)
    obtain acc(usize(_76), write)
    obtain acc(struct$m_std$$arch$$x86_64$$__m128i(_62), write)
    obtain acc(_2.val_ref, write)
    obtain acc(struct$m_std$$arch$$x86_64$$__m128i(_61), read)
    assert true
    assert (true) && ((true) && ((true) && (true)))
    assert ((_preserve$1) == (_2.val_ref)) && (true)
    exhale (acc(usize(_76), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_62), write)) && ((acc(_2.val_ref, write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_61), read)) && (true))))
    inhale false
    Return
  label bb35 // 90
    // ========== bb35 ==========
    __t35 := copy true
    // [mir] StorageDead(_76)
    // [mir] StorageLive(_85)
    // [mir] _74 = const ()
    // [mir] StorageDead(_85)
    // [mir] StorageDead(_75)
    // [mir] StorageDead(_74)
    // [mir] StorageLive(_87)
    // [mir] StorageLive(_88)
    // [mir] StorageLive(_89)
    // [mir] _89 = const "128 > 64 init"
    _89 := builtin$havoc_ref()
    inhale acc(_89.val_ref, write)
    inhale acc(Str(_89.val_ref), read)
    // [mir] _88 = &'?26 (*_89)
    _88 := builtin$havoc_ref()
    inhale acc(_88.val_ref, write)
    _88.val_ref := borrow _89.val_ref // L35
    label l138
    // [mir] StorageLive(_90)
    // [mir] _90 = _62
    _90 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_90), write)
    inhale (snap(_62)) == (snap(_90))
    label l139
    // [mir] _87 = specialized::pclmulqdq::debug(move _88, move _90) -> [return: bb36, unwind: bb63]
    label l140
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(_88.val_ref, write)) && ((true) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_90), write)) && (true)))
    _87 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_87), write)
    transfer perm _88.val_ref --> old[l140](_88.val_ref) // unchecked: true
    inhale (true) && (true)
    inhale true
    exhale true
    label l141
    Goto(cfg:91)
  label l142 // 91
    // ========== l142 ==========
    // MIR edge bb35 --> bb36
    // Expire borrows
    expire_borrows ReborrowingDAG(L36,L35,L45,)

    Goto(cfg:92)
  label bb36 // 92
    // ========== bb36 ==========
    __t36 := copy true
    // [mir] StorageDead(_90)
    // [mir] StorageDead(_88)
    // [mir] StorageDead(_89)
    // [mir] StorageDead(_87)
    // [mir] StorageLive(_91)
    // [mir] _91 = std::mem::drop::<i64>(const _) -> [return: bb37, unwind: bb63]
    label l143
    _t139 := builtin$havoc_ref()
    inhale acc(i64(_t139), write)
    assert true
    assert (true) && (true)
    exhale (acc(i64(_t139), write)) && (true)
    _91 := builtin$havoc_ref()
    inhale true
    inhale acc(tuple0$(_91), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l144
    Goto(cfg:93)
  label bb37 // 93
    // ========== bb37 ==========
    __t37 := copy true
    // [mir] StorageDead(_91)
    // [mir] StorageLive(_92)
    // [mir] StorageLive(_93)
    // [mir] StorageLive(_94)
    // [mir] _94 = _62
    _94 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_94), write)
    inhale (snap(_62)) == (snap(_94))
    label l145
    // [mir] StorageLive(_95)
    // [mir] _95 = _61
    _95 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_95), write)
    inhale (snap(_61)) == (snap(_95))
    label l146
    // [mir] _93 = std::arch::x86_64::_mm_clmulepi64_si128::<16>(move _94, move _95) -> [return: bb38, unwind: bb63]
    label l147
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_94), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_95), write)) && (true))
    _93 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_93), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l148
    Goto(cfg:94)
  label bb38 // 94
    // ========== bb38 ==========
    __t38 := copy true
    // [mir] StorageDead(_95)
    // [mir] StorageDead(_94)
    // [mir] StorageLive(_96)
    // [mir] StorageLive(_97)
    // [mir] _97 = _62
    _97 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_97), write)
    inhale (snap(_62)) == (snap(_97))
    label l149
    // [mir] _96 = std::arch::x86_64::_mm_srli_si128::<8>(move _97) -> [return: bb39, unwind: bb63]
    label l150
    assert true
    assert (true) && (true)
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_97), write)) && (true)
    _96 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_96), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l151
    Goto(cfg:95)
  label bb39 // 95
    // ========== bb39 ==========
    __t39 := copy true
    // [mir] StorageDead(_97)
    // [mir] _92 = std::arch::x86_64::_mm_xor_si128(move _93, move _96) -> [return: bb40, unwind: bb63]
    label l152
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_93), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_96), write)) && (true))
    _92 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_92), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l153
    Goto(cfg:96)
  label bb40 // 96
    // ========== bb40 ==========
    __t40 := copy true
    // [mir] StorageDead(_96)
    // [mir] StorageDead(_93)
    // [mir] FakeRead(ForLet(None), _92)
    // [mir] StorageLive(_98)
    // [mir] StorageLive(_99)
    // [mir] StorageLive(_100)
    // [mir] StorageLive(_101)
    // [mir] _101 = _92
    _101 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_101), write)
    inhale (snap(_92)) == (snap(_101))
    label l154
    // [mir] StorageLive(_102)
    // [mir] StorageLive(_103)
    // [mir] _103 = Not(const 0_i32)
    _103 := builtin$havoc_ref()
    inhale acc(_103.val_int, write)
    _103.val_int := copy !(0)
    // [mir] _102 = std::arch::x86_64::_mm_set_epi32(const 0_i32, const 0_i32, const 0_i32, move _103) -> [return: bb41, unwind: bb63]
    label l155
    _t140 := builtin$havoc_ref()
    inhale acc(i32(_t140), write)
    _t141 := builtin$havoc_ref()
    inhale acc(i32(_t141), write)
    _t142 := builtin$havoc_ref()
    inhale acc(i32(_t142), write)
    assert true
    assert (true) && ((true) && ((true) && ((true) && (true))))
    exhale (acc(i32(_t140), write)) && ((acc(i32(_t141), write)) && ((acc(i32(_t142), write)) && ((acc(i32(_103), write)) && (true))))
    _102 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_102), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l156
    Goto(cfg:97)
  label bb41 // 97
    // ========== bb41 ==========
    __t41 := copy true
    // [mir] StorageDead(_103)
    // [mir] _100 = std::arch::x86_64::_mm_and_si128(move _101, move _102) -> [return: bb42, unwind: bb63]
    label l157
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_101), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_102), write)) && (true))
    _100 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_100), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l158
    Goto(cfg:98)
  label bb42 // 98
    // ========== bb42 ==========
    __t42 := copy true
    // [mir] StorageDead(_102)
    // [mir] StorageDead(_101)
    // [mir] StorageLive(_104)
    // [mir] _104 = std::arch::x86_64::_mm_set_epi64x(const 0_i64, const _) -> [return: bb43, unwind: bb63]
    label l159
    _t143 := builtin$havoc_ref()
    inhale acc(i64(_t143), write)
    _t144 := builtin$havoc_ref()
    inhale acc(i64(_t144), write)
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(i64(_t143), write)) && ((acc(i64(_t144), write)) && (true))
    _104 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_104), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l160
    Goto(cfg:99)
  label bb43 // 99
    // ========== bb43 ==========
    __t43 := copy true
    // [mir] _99 = std::arch::x86_64::_mm_clmulepi64_si128::<0>(move _100, move _104) -> [return: bb44, unwind: bb63]
    label l161
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_100), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_104), write)) && (true))
    _99 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_99), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l162
    Goto(cfg:100)
  label bb44 // 100
    // ========== bb44 ==========
    __t44 := copy true
    // [mir] StorageDead(_104)
    // [mir] StorageDead(_100)
    // [mir] StorageLive(_105)
    // [mir] StorageLive(_106)
    // [mir] _106 = _92
    _106 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_106), write)
    inhale (snap(_92)) == (snap(_106))
    label l163
    // [mir] _105 = std::arch::x86_64::_mm_srli_si128::<4>(move _106) -> [return: bb45, unwind: bb63]
    label l164
    assert true
    assert (true) && (true)
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_106), write)) && (true)
    _105 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_105), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l165
    Goto(cfg:101)
  label bb45 // 101
    // ========== bb45 ==========
    __t45 := copy true
    // [mir] StorageDead(_106)
    // [mir] _98 = std::arch::x86_64::_mm_xor_si128(move _99, move _105) -> [return: bb46, unwind: bb63]
    label l166
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_99), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_105), write)) && (true))
    _98 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_98), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l167
    Goto(cfg:102)
  label bb46 // 102
    // ========== bb46 ==========
    __t46 := copy true
    // [mir] StorageDead(_105)
    // [mir] StorageDead(_99)
    // [mir] FakeRead(ForLet(None), _98)
    // [mir] StorageLive(_107)
    // [mir] StorageLive(_108)
    // [mir] StorageLive(_109)
    // [mir] _109 = const "128 > 64 xx"
    _109 := builtin$havoc_ref()
    inhale acc(_109.val_ref, write)
    inhale acc(Str(_109.val_ref), read)
    // [mir] _108 = &'?28 (*_109)
    _108 := builtin$havoc_ref()
    inhale acc(_108.val_ref, write)
    _108.val_ref := borrow _109.val_ref // L21
    label l168
    // [mir] StorageLive(_110)
    // [mir] _110 = _98
    _110 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_110), write)
    inhale (snap(_98)) == (snap(_110))
    label l169
    // [mir] _107 = specialized::pclmulqdq::debug(move _108, move _110) -> [return: bb47, unwind: bb63]
    label l170
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(_108.val_ref, write)) && ((true) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_110), write)) && (true)))
    _107 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_107), write)
    transfer perm _108.val_ref --> old[l170](_108.val_ref) // unchecked: true
    inhale (true) && (true)
    inhale true
    exhale true
    label l171
    Goto(cfg:103)
  label l172 // 103
    // ========== l172 ==========
    // MIR edge bb46 --> bb47
    // Expire borrows
    expire_borrows ReborrowingDAG(L46,L21,L31,)

    Goto(cfg:104)
  label bb47 // 104
    // ========== bb47 ==========
    __t47 := copy true
    // [mir] StorageDead(_110)
    // [mir] StorageDead(_108)
    // [mir] StorageDead(_109)
    // [mir] StorageDead(_107)
    // [mir] StorageLive(_111)
    // [mir] _111 = std::arch::x86_64::_mm_set_epi64x(const _, const _) -> [return: bb48, unwind: bb63]
    label l173
    _t145 := builtin$havoc_ref()
    inhale acc(i64(_t145), write)
    _t146 := builtin$havoc_ref()
    inhale acc(i64(_t146), write)
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(i64(_t145), write)) && ((acc(i64(_t146), write)) && (true))
    _111 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_111), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l174
    Goto(cfg:105)
  label bb48 // 105
    // ========== bb48 ==========
    __t48 := copy true
    // [mir] FakeRead(ForLet(None), _111)
    // [mir] StorageLive(_112)
    // [mir] StorageLive(_113)
    // [mir] StorageLive(_114)
    // [mir] _114 = _98
    _114 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_114), write)
    inhale (snap(_98)) == (snap(_114))
    label l175
    // [mir] StorageLive(_115)
    // [mir] StorageLive(_116)
    // [mir] _116 = Not(const 0_i32)
    _116 := builtin$havoc_ref()
    inhale acc(_116.val_int, write)
    _116.val_int := copy !(0)
    // [mir] _115 = std::arch::x86_64::_mm_set_epi32(const 0_i32, const 0_i32, const 0_i32, move _116) -> [return: bb49, unwind: bb63]
    label l176
    _t147 := builtin$havoc_ref()
    inhale acc(i32(_t147), write)
    _t148 := builtin$havoc_ref()
    inhale acc(i32(_t148), write)
    _t149 := builtin$havoc_ref()
    inhale acc(i32(_t149), write)
    assert true
    assert (true) && ((true) && ((true) && ((true) && (true))))
    exhale (acc(i32(_t147), write)) && ((acc(i32(_t148), write)) && ((acc(i32(_t149), write)) && ((acc(i32(_116), write)) && (true))))
    _115 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_115), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l177
    Goto(cfg:106)
  label bb49 // 106
    // ========== bb49 ==========
    __t49 := copy true
    // [mir] StorageDead(_116)
    // [mir] _113 = std::arch::x86_64::_mm_and_si128(move _114, move _115) -> [return: bb50, unwind: bb63]
    label l178
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_114), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_115), write)) && (true))
    _113 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_113), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l179
    Goto(cfg:107)
  label bb50 // 107
    // ========== bb50 ==========
    __t50 := copy true
    // [mir] StorageDead(_115)
    // [mir] StorageDead(_114)
    // [mir] StorageLive(_117)
    // [mir] _117 = _111
    _117 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_117), write)
    inhale (snap(_111)) == (snap(_117))
    label l180
    // [mir] _112 = std::arch::x86_64::_mm_clmulepi64_si128::<16>(move _113, move _117) -> [return: bb51, unwind: bb63]
    label l181
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_113), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_117), write)) && (true))
    _112 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_112), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l182
    Goto(cfg:108)
  label bb51 // 108
    // ========== bb51 ==========
    __t51 := copy true
    // [mir] StorageDead(_117)
    // [mir] StorageDead(_113)
    // [mir] FakeRead(ForLet(None), _112)
    // [mir] StorageLive(_118)
    // [mir] StorageLive(_119)
    // [mir] StorageLive(_120)
    // [mir] _120 = _112
    _120 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_120), write)
    inhale (snap(_112)) == (snap(_120))
    label l183
    // [mir] StorageLive(_121)
    // [mir] StorageLive(_122)
    // [mir] _122 = Not(const 0_i32)
    _122 := builtin$havoc_ref()
    inhale acc(_122.val_int, write)
    _122.val_int := copy !(0)
    // [mir] _121 = std::arch::x86_64::_mm_set_epi32(const 0_i32, const 0_i32, const 0_i32, move _122) -> [return: bb52, unwind: bb63]
    label l184
    _t150 := builtin$havoc_ref()
    inhale acc(i32(_t150), write)
    _t151 := builtin$havoc_ref()
    inhale acc(i32(_t151), write)
    _t152 := builtin$havoc_ref()
    inhale acc(i32(_t152), write)
    assert true
    assert (true) && ((true) && ((true) && ((true) && (true))))
    exhale (acc(i32(_t150), write)) && ((acc(i32(_t151), write)) && ((acc(i32(_t152), write)) && ((acc(i32(_122), write)) && (true))))
    _121 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_121), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l185
    Goto(cfg:109)
  label bb52 // 109
    // ========== bb52 ==========
    __t52 := copy true
    // [mir] StorageDead(_122)
    // [mir] _119 = std::arch::x86_64::_mm_and_si128(move _120, move _121) -> [return: bb53, unwind: bb63]
    label l186
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_120), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_121), write)) && (true))
    _119 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_119), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l187
    Goto(cfg:110)
  label bb53 // 110
    // ========== bb53 ==========
    __t53 := copy true
    // [mir] StorageDead(_121)
    // [mir] StorageDead(_120)
    // [mir] StorageLive(_123)
    // [mir] _123 = _111
    _123 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_123), write)
    inhale (snap(_111)) == (snap(_123))
    label l188
    // [mir] _118 = std::arch::x86_64::_mm_clmulepi64_si128::<0>(move _119, move _123) -> [return: bb54, unwind: bb63]
    label l189
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_119), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_123), write)) && (true))
    _118 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_118), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l190
    Goto(cfg:111)
  label bb54 // 111
    // ========== bb54 ==========
    __t54 := copy true
    // [mir] StorageDead(_123)
    // [mir] StorageDead(_119)
    // [mir] FakeRead(ForLet(None), _118)
    // [mir] StorageLive(_124)
    // [mir] StorageLive(_125)
    // [mir] StorageLive(_126)
    // [mir] StorageLive(_127)
    // [mir] _127 = _98
    _127 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_127), write)
    inhale (snap(_98)) == (snap(_127))
    label l191
    // [mir] StorageLive(_128)
    // [mir] _128 = _118
    _128 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_128), write)
    inhale (snap(_118)) == (snap(_128))
    label l192
    // [mir] _126 = std::arch::x86_64::_mm_xor_si128(move _127, move _128) -> [return: bb55, unwind: bb63]
    label l193
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_127), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_128), write)) && (true))
    _126 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_126), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l194
    Goto(cfg:112)
  label bb55 // 112
    // ========== bb55 ==========
    __t55 := copy true
    // [mir] StorageDead(_128)
    // [mir] StorageDead(_127)
    // [mir] _125 = std::arch::x86_64::_mm_extract_epi32::<1>(move _126) -> [return: bb56, unwind: bb63]
    label l195
    assert true
    assert (true) && (true)
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_126), write)) && (true)
    _125 := builtin$havoc_ref()
    inhale true
    inhale acc(i32(_125), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l196
    Goto(cfg:113)
  label bb56 // 113
    // ========== bb56 ==========
    __t56 := copy true
    // [mir] StorageDead(_126)
    // [mir] _124 = move _125 as u32 (IntToInt)
    _124 := builtin$havoc_ref()
    inhale acc(_124.val_int, write)
    _124.val_int := copy builtin$cast$i32$u32<>(_125.val_int)
    // [mir] StorageDead(_125)
    // [mir] FakeRead(ForLet(None), _124)
    // [mir] StorageLive(_129)
    // [mir] StorageLive(_130)
    // [mir] _130 = &'?29 (*_2)
    _130 := builtin$havoc_ref()
    inhale acc(_130.val_ref, write)
    _130.val_ref := borrow _2.val_ref // L22
    label l197
    // [mir] _129 = core::slice::<impl [u8]>::is_empty(move _130) -> [return: bb57, unwind: bb63]
    label l198
    assert true
    assert (true) && (true)
    exhale (acc(_130.val_ref, write)) && ((true) && (true))
    _129 := builtin$havoc_ref()
    inhale true
    inhale acc(bool(_129), write)
    transfer perm _130.val_ref --> old[l198](_130.val_ref) // unchecked: true
    inhale (true) && (true)
    inhale true
    exhale true
    label l199
    Goto(cfg:114)
  label l200 // 114
    // ========== l200 ==========
    // MIR edge bb56 --> bb57
    // Expire borrows
    expire_borrows ReborrowingDAG(L40,L22,)

    Goto(cfg:115)
  label bb57 // 115
    // ========== bb57 ==========
    __t57 := copy true
    // [mir] switchInt(move _129) -> [0: bb59, otherwise: bb58]
    __t70 := copy _129.val_bool
    GotoSwitch([(Local(Local { variable: __t70: Bool, position: Position { line: 0, column: 0, id: 0 } }), cfg:117)], cfg:116)
  label l201 // 116
    // ========== l201 ==========
    // MIR edge bb57 --> bb59
    Goto(cfg:119)
  label l202 // 117
    // ========== l202 ==========
    // MIR edge bb57 --> bb58
    Goto(cfg:118)
  label bb58 // 118
    // ========== bb58 ==========
    __t58 := copy true
    // [mir] StorageDead(_130)
    // [mir] StorageLive(_134)
    // [mir] _134 = _124
    _134 := builtin$havoc_ref()
    inhale acc(_134.val_int, write)
    _134.val_int := copy _124.val_int
    label l203
    // [mir] _0 = Not(move _134)
    _0 := builtin$havoc_ref()
    inhale acc(_0.val_int, write)
    _0.val_int := copy !(_134.val_int)
    // [mir] StorageDead(_134)
    // [mir] goto -> bb61
    Goto(cfg:122)
  label bb59 // 119
    // ========== bb59 ==========
    __t59 := copy true
    // [mir] StorageDead(_130)
    // [mir] StorageLive(_131)
    // [mir] StorageLive(_132)
    // [mir] _132 = _124
    _132 := builtin$havoc_ref()
    inhale acc(_132.val_int, write)
    _132.val_int := copy _124.val_int
    label l204
    // [mir] _131 = Not(move _132)
    _131 := builtin$havoc_ref()
    inhale acc(_131.val_int, write)
    _131.val_int := copy !(_132.val_int)
    // [mir] StorageDead(_132)
    // [mir] StorageLive(_133)
    // [mir] _133 = &'?30 (*_2)
    _133 := builtin$havoc_ref()
    inhale acc(_133.val_ref, write)
    _133.val_ref := borrow _2.val_ref // L33
    label l205
    // [mir] _0 = baseline::update_fast_16(move _131, move _133) -> [return: bb60, unwind: bb63]
    label l206
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(u32(_131), write)) && ((acc(_133.val_ref, write)) && ((true) && (true)))
    _0 := builtin$havoc_ref()
    inhale true
    inhale acc(u32(_0), write)
    transfer perm _133.val_ref --> old[l206](_133.val_ref) // unchecked: true
    inhale (true) && (true)
    inhale true
    exhale true
    label l207
    Goto(cfg:120)
  label l208 // 120
    // ========== l208 ==========
    // MIR edge bb59 --> bb60
    // Expire borrows
    expire_borrows ReborrowingDAG(L25,L33,)

    Goto(cfg:121)
  label bb60 // 121
    // ========== bb60 ==========
    __t60 := copy true
    // [mir] StorageDead(_133)
    // [mir] StorageDead(_131)
    // [mir] goto -> bb61
    Goto(cfg:122)
  label bb61 // 122
    // ========== bb61 ==========
    __t61 := copy true
    // [mir] StorageDead(_129)
    // [mir] StorageDead(_124)
    // [mir] StorageDead(_118)
    // [mir] StorageDead(_112)
    // [mir] StorageDead(_111)
    // [mir] StorageDead(_98)
    // [mir] StorageDead(_92)
    // [mir] StorageDead(_62)
    // [mir] StorageDead(_61)
    // [mir] StorageDead(_28)
    // [mir] StorageDead(_19)
    // [mir] StorageDead(_16)
    // [mir] StorageDead(_13)
    // [mir] StorageDead(_10)
    // [mir] goto -> bb62
    Goto(cfg:123)
  label bb62 // 123
    // ========== bb62 ==========
    __t62 := copy true
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_specialized$$pclmulqdq$$calculate(...)
    returns (_0: Ref(u32))
{
  label stub // 0
    // ========== stub ==========
    // Def path: "crc32fast::specialized::pclmulqdq::calculate"
    // Span: src/specialized/pclmulqdq.rs:92:1: 190:2 (#0)
    Return
  label end_of_method
}


method m_specialized$$pclmulqdq$$reduce128(...)
    returns (_0: Ref(struct$m_std$$arch$$x86_64$$__m128i))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    _1: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _2: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _3: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _4: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _5: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _6: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _7: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _8: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _9: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _10: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _11: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _12: Ref(struct$m_std$$arch$$x86_64$$__m128i)
    _13: Ref(struct$m_std$$arch$$x86_64$$__m128i)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::specialized::pclmulqdq::reduce128"
    // Span: src/specialized/pclmulqdq.rs:192:1: 196:2 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    // Preconditions:
    inhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_1), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_2), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_3), write)) && (true)))
    inhale true
    inhale (true) && ((true) && ((true) && (true)))
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l16
    // Fold predicates for &mut args and transfer borrow permissions to old
    // Fold the result
    obtain acc(struct$m_std$$arch$$x86_64$$__m128i(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale true
    // Exhale permissions of postcondition (2/3)
    exhale acc(struct$m_std$$arch$$x86_64$$__m128i(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_4)
    // [mir] StorageLive(_5)
    // [mir] _5 = _1
    _5 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_5), write)
    inhale (snap(_1)) == (snap(_5))
    label l0
    // [mir] StorageLive(_6)
    // [mir] _6 = _3
    _6 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_6), write)
    inhale (snap(_3)) == (snap(_6))
    label l1
    // [mir] _4 = std::arch::x86_64::_mm_clmulepi64_si128::<0>(move _5, move _6) -> [return: bb1, unwind: bb5]
    label l2
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_5), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_6), write)) && (true))
    _4 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_4), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l3
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_6)
    // [mir] StorageDead(_5)
    // [mir] FakeRead(ForLet(None), _4)
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = _1
    _8 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_8), write)
    inhale (snap(_1)) == (snap(_8))
    label l4
    // [mir] StorageLive(_9)
    // [mir] _9 = _3
    _9 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_9), write)
    inhale (snap(_3)) == (snap(_9))
    label l5
    // [mir] _7 = std::arch::x86_64::_mm_clmulepi64_si128::<17>(move _8, move _9) -> [return: bb2, unwind: bb5]
    label l6
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_8), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_9), write)) && (true))
    _7 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_7), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l7
    Goto(cfg:4)
  label bb2 // 4
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] StorageDead(_9)
    // [mir] StorageDead(_8)
    // [mir] FakeRead(ForLet(None), _7)
    // [mir] StorageLive(_10)
    // [mir] StorageLive(_11)
    // [mir] _11 = _2
    _11 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_11), write)
    inhale (snap(_2)) == (snap(_11))
    label l8
    // [mir] StorageLive(_12)
    // [mir] _12 = _4
    _12 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_12), write)
    inhale (snap(_4)) == (snap(_12))
    label l9
    // [mir] _10 = std::arch::x86_64::_mm_xor_si128(move _11, move _12) -> [return: bb3, unwind: bb5]
    label l10
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_11), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_12), write)) && (true))
    _10 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_10), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l11
    Goto(cfg:5)
  label bb3 // 5
    // ========== bb3 ==========
    __t3 := copy true
    // [mir] StorageDead(_12)
    // [mir] StorageDead(_11)
    // [mir] StorageLive(_13)
    // [mir] _13 = _7
    _13 := builtin$havoc_ref()
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_13), write)
    inhale (snap(_7)) == (snap(_13))
    label l12
    // [mir] _0 = std::arch::x86_64::_mm_xor_si128(move _10, move _13) -> [return: bb4, unwind: bb5]
    label l13
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(struct$m_std$$arch$$x86_64$$__m128i(_10), write)) && ((acc(struct$m_std$$arch$$x86_64$$__m128i(_13), write)) && (true))
    _0 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_std$$arch$$x86_64$$__m128i(_0), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l14
    Goto(cfg:6)
  label bb4 // 6
    // ========== bb4 ==========
    __t4 := copy true
    // [mir] StorageDead(_13)
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_4)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_specialized$$pclmulqdq$$get(...)
    returns (_0: Ref(struct$m_std$$arch$$x86_64$$__m128i))
{
  label stub // 0
    // ========== stub ==========
    // Def path: "crc32fast::specialized::pclmulqdq::get"
    // Span: src/specialized/pclmulqdq.rs:198:1: 203:2 (#0)
    Return
  label end_of_method
}


method m_$openang$baseline$$State$space$as$space$std$$clone$$Clone$closeang$$$clone(...)
    returns (_0: Ref(struct$m_baseline$$State))
{
    __t0: Bool
    __t1: Bool
    _old$pre$0: Ref(struct$m_baseline$$State)
    _1: Ref(ref$struct$m_baseline$$State)
    _2: Ref(u32)
    _3: Ref(ref$u32)
    _4: Ref(ref$u32)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::baseline::{impl#1}::clone"
    // Span: src/baseline.rs:3:10: 3:15 (#5)
    __t0 := copy false
    __t1 := copy false
    // Preconditions:
    inhale (acc(_1.val_ref, write)) && ((acc(struct$m_baseline$$State(_1.val_ref), read)) && (true))
    inhale true
    inhale (true) && (true)
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l7
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(struct$m_baseline$$State(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(struct$m_baseline$$State(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(struct$m_baseline$$State(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(struct$m_baseline$$State(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_2)
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] _4 = &'?3 ((*_1).0: u32)
    _4 := builtin$havoc_ref()
    inhale acc(_4.val_ref, write)
    _4.val_ref := borrow _1.val_ref.f$state // L5
    label l0
    // [mir] _3 = &'?4 (*_4)
    _3 := builtin$havoc_ref()
    inhale acc(_3.val_ref, write)
    _3.val_ref := borrow _4.val_ref // L4
    label l1
    // [mir] _2 = <u32 as std::clone::Clone>::clone(move _3) -> [return: bb1, unwind: bb2]
    label l2
    assert true
    assert (true) && (true)
    exhale (acc(_3.val_ref, write)) && ((true) && (true))
    _2 := builtin$havoc_ref()
    inhale true
    inhale acc(u32(_2), write)
    transfer perm _3.val_ref --> old[l2](_3.val_ref) // unchecked: true
    inhale (true) && (true)
    inhale true
    exhale true
    label l3
    Goto(cfg:3)
  label l4 // 3
    // ========== l4 ==========
    // MIR edge bb0 --> bb1
    // Expire borrows
    expire_borrows ReborrowingDAG(L3,L4,L5,)

    Goto(cfg:4)
  label bb1 // 4
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_3)
    // [mir] _0 = baseline::State { state: move _2 }
    _0 := builtin$havoc_ref()
    inhale acc(struct$m_baseline$$State(_0), write)
    _0.f$state := move _2
    label l5
    // [mir] StorageDead(_2)
    // [mir] StorageDead(_4)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_baseline$$State$$new(...)
    returns (_0: Ref(struct$m_baseline$$State))
{
    __t0: Bool
    _1: Ref(u32)
    _2: Ref(u32)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::baseline::{impl#0}::new"
    // Span: src/baseline.rs:9:5: 11:6 (#0)
    __t0 := copy false
    // Preconditions:
    inhale (acc(u32(_1), write)) && (true)
    inhale true
    inhale (true) && (true)
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l3
    // Fold predicates for &mut args and transfer borrow permissions to old
    // Fold the result
    obtain acc(struct$m_baseline$$State(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale true
    // Exhale permissions of postcondition (2/3)
    exhale acc(struct$m_baseline$$State(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_2)
    // [mir] _2 = _1
    _2 := builtin$havoc_ref()
    inhale acc(_2.val_int, write)
    _2.val_int := copy _1.val_int
    label l0
    // [mir] _0 = baseline::State { state: move _2 }
    _0 := builtin$havoc_ref()
    inhale acc(struct$m_baseline$$State(_0), write)
    _0.f$state := move _2
    label l1
    // [mir] StorageDead(_2)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_baseline$$State$$update(...)
    returns (_0: Ref(tuple0$))
{
    __t0: Bool
    __t1: Bool
    _old$pre$0: Ref(struct$m_baseline$$State)
    _old$pre$1: Ref(Slice$u8)
    _1: Ref(ref$struct$m_baseline$$State)
    _2: Ref(ref$Slice$u8)
    _3: Ref(u32)
    _4: Ref(u32)
    _5: Ref(ref$Slice$u8)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::baseline::{impl#0}::update"
    // Span: src/baseline.rs:13:5: 15:6 (#0)
    __t0 := copy false
    __t1 := copy false
    // Preconditions:
    inhale (acc(_1.val_ref, write)) && ((acc(struct$m_baseline$$State(_1.val_ref), write)) && ((acc(_2.val_ref, write)) && ((acc(Slice$u8(_2.val_ref), read)) && (true))))
    inhale true
    inhale (true) && ((true) && (true))
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l7
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(struct$m_baseline$$State(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(Slice$u8(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(tuple0$(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && ((true) && (true))
    // Exhale permissions of postcondition (1/3)
    exhale (acc(struct$m_baseline$$State(_old$pre$0), write)) && ((acc(Slice$u8(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(tuple0$(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] _4 = ((*_1).0: u32)
    _4 := builtin$havoc_ref()
    inhale acc(_4.val_int, write)
    _4.val_int := copy _1.val_ref.f$state.val_int
    label l0
    // [mir] StorageLive(_5)
    // [mir] _5 = &'?4 (*_2)
    _5 := builtin$havoc_ref()
    inhale acc(_5.val_ref, write)
    _5.val_ref := borrow _2.val_ref // L4
    label l1
    // [mir] _3 = baseline::update_fast_16(move _4, move _5) -> [return: bb1, unwind: bb2]
    label l2
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(u32(_4), write)) && ((acc(_5.val_ref, write)) && ((true) && (true)))
    _3 := builtin$havoc_ref()
    inhale true
    inhale acc(u32(_3), write)
    transfer perm _5.val_ref --> old[l2](_5.val_ref) // unchecked: true
    inhale (true) && (true)
    inhale true
    exhale true
    label l3
    Goto(cfg:3)
  label l4 // 3
    // ========== l4 ==========
    // MIR edge bb0 --> bb1
    // Expire borrows
    expire_borrows ReborrowingDAG(L5,L4,)

    Goto(cfg:4)
  label bb1 // 4
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_5)
    // [mir] StorageDead(_4)
    // [mir] ((*_1).0: u32) = move _3
    _1.val_ref.f$state := move _3
    label l5
    // [mir] StorageDead(_3)
    // [mir] _0 = const ()
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_baseline$$State$$finalize(...)
    returns (_0: Ref(u32))
{
    __t0: Bool
    _1: Ref(struct$m_baseline$$State)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::baseline::{impl#0}::finalize"
    // Span: src/baseline.rs:17:5: 19:6 (#0)
    __t0 := copy false
    // Preconditions:
    inhale (acc(struct$m_baseline$$State(_1), write)) && (true)
    inhale true
    inhale (true) && (true)
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l2
    // Fold predicates for &mut args and transfer borrow permissions to old
    // Fold the result
    obtain acc(u32(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale true
    // Exhale permissions of postcondition (2/3)
    exhale acc(u32(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] _0 = (_1.0: u32)
    _0 := builtin$havoc_ref()
    inhale acc(_0.val_int, write)
    _0.val_int := copy _1.f$state.val_int
    label l0
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_baseline$$State$$reset(...)
    returns (_0: Ref(tuple0$))
{
    __t0: Bool
    _old$pre$0: Ref(struct$m_baseline$$State)
    _1: Ref(ref$struct$m_baseline$$State)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::baseline::{impl#0}::reset"
    // Span: src/baseline.rs:21:5: 23:6 (#0)
    __t0 := copy false
    // Preconditions:
    inhale (acc(_1.val_ref, write)) && ((acc(struct$m_baseline$$State(_1.val_ref), write)) && (true))
    inhale true
    inhale (true) && (true)
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l1
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(struct$m_baseline$$State(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(tuple0$(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && ((true) && (true))
    // Exhale permissions of postcondition (1/3)
    exhale (acc(struct$m_baseline$$State(_old$pre$0), write)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(tuple0$(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] ((*_1).0: u32) = const 0_u32
    _1.val_ref.f$state.val_int := copy 0
    // [mir] _0 = const ()
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_baseline$$State$$combine(...)
    returns (_0: Ref(tuple0$))
{
    __t0: Bool
    __t1: Bool
    _old$pre$0: Ref(struct$m_baseline$$State)
    _1: Ref(ref$struct$m_baseline$$State)
    _2: Ref(u32)
    _3: Ref(u64)
    _4: Ref(u32)
    _5: Ref(u32)
    _6: Ref(u32)
    _7: Ref(u64)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::baseline::{impl#0}::combine"
    // Span: src/baseline.rs:25:5: 27:6 (#0)
    __t0 := copy false
    __t1 := copy false
    // Preconditions:
    inhale (acc(_1.val_ref, write)) && ((acc(struct$m_baseline$$State(_1.val_ref), write)) && ((acc(u32(_2), write)) && ((acc(u64(_3), write)) && (true))))
    inhale true
    inhale (true) && ((true) && ((true) && (true)))
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l7
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(struct$m_baseline$$State(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(tuple0$(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && ((true) && (true))
    // Exhale permissions of postcondition (1/3)
    exhale (acc(struct$m_baseline$$State(_old$pre$0), write)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(tuple0$(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_4)
    // [mir] StorageLive(_5)
    // [mir] _5 = ((*_1).0: u32)
    _5 := builtin$havoc_ref()
    inhale acc(_5.val_int, write)
    _5.val_int := copy _1.val_ref.f$state.val_int
    label l0
    // [mir] StorageLive(_6)
    // [mir] _6 = _2
    _6 := builtin$havoc_ref()
    inhale acc(_6.val_int, write)
    _6.val_int := copy _2.val_int
    label l1
    // [mir] StorageLive(_7)
    // [mir] _7 = _3
    _7 := builtin$havoc_ref()
    inhale acc(_7.val_int, write)
    _7.val_int := copy _3.val_int
    label l2
    // [mir] _4 = combine::combine(move _5, move _6, move _7) -> [return: bb1, unwind: bb2]
    label l3
    assert true
    assert (true) && ((true) && ((true) && (true)))
    exhale (acc(u32(_5), write)) && ((acc(u32(_6), write)) && ((acc(u64(_7), write)) && (true)))
    _4 := builtin$havoc_ref()
    inhale true
    inhale acc(u32(_4), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l4
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_6)
    // [mir] StorageDead(_5)
    // [mir] ((*_1).0: u32) = move _4
    _1.val_ref.f$state := move _4
    label l5
    // [mir] StorageDead(_4)
    // [mir] _0 = const ()
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_$openang$specialized$$pclmulqdq$$State$space$as$space$std$$clone$$Clone$closeang$$$clone(...)
    returns (_0: Ref(struct$m_specialized$$pclmulqdq$$State))
{
    __t0: Bool
    __t1: Bool
    _old$pre$0: Ref(struct$m_specialized$$pclmulqdq$$State)
    _1: Ref(ref$struct$m_specialized$$pclmulqdq$$State)
    _2: Ref(u32)
    _3: Ref(ref$u32)
    _4: Ref(ref$u32)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::specialized::pclmulqdq::{impl#1}::clone"
    // Span: src/specialized/pclmulqdq.rs:6:10: 6:15 (#8)
    __t0 := copy false
    __t1 := copy false
    // Preconditions:
    inhale (acc(_1.val_ref, write)) && ((acc(struct$m_specialized$$pclmulqdq$$State(_1.val_ref), read)) && (true))
    inhale true
    inhale (true) && (true)
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l7
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(struct$m_specialized$$pclmulqdq$$State(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(struct$m_specialized$$pclmulqdq$$State(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(struct$m_specialized$$pclmulqdq$$State(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(struct$m_specialized$$pclmulqdq$$State(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_2)
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] _4 = &'?3 ((*_1).0: u32)
    _4 := builtin$havoc_ref()
    inhale acc(_4.val_ref, write)
    _4.val_ref := borrow _1.val_ref.f$state // L5
    label l0
    // [mir] _3 = &'?4 (*_4)
    _3 := builtin$havoc_ref()
    inhale acc(_3.val_ref, write)
    _3.val_ref := borrow _4.val_ref // L4
    label l1
    // [mir] _2 = <u32 as std::clone::Clone>::clone(move _3) -> [return: bb1, unwind: bb2]
    label l2
    assert true
    assert (true) && (true)
    exhale (acc(_3.val_ref, write)) && ((true) && (true))
    _2 := builtin$havoc_ref()
    inhale true
    inhale acc(u32(_2), write)
    transfer perm _3.val_ref --> old[l2](_3.val_ref) // unchecked: true
    inhale (true) && (true)
    inhale true
    exhale true
    label l3
    Goto(cfg:3)
  label l4 // 3
    // ========== l4 ==========
    // MIR edge bb0 --> bb1
    // Expire borrows
    expire_borrows ReborrowingDAG(L3,L4,L5,)

    Goto(cfg:4)
  label bb1 // 4
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_3)
    // [mir] _0 = specialized::pclmulqdq::State { state: move _2 }
    _0 := builtin$havoc_ref()
    inhale acc(struct$m_specialized$$pclmulqdq$$State(_0), write)
    _0.f$state := move _2
    label l5
    // [mir] StorageDead(_2)
    // [mir] StorageDead(_4)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


function m_std$$option$$Option$_beg_$struct$m_specialized$$pclmulqdq$$State$_end_$$discriminant$$<>(self: Ref(m_std$$option$$Option$_beg_$struct$m_specialized$$pclmulqdq$$State$_end_)): Int
  requires acc(m_std$$option$$Option$_beg_$struct$m_specialized$$pclmulqdq$$State$_end_(self), read)
  ensures (((0) <= (__result)) && ((__result) <= (1))) || (false)
  ensures (discriminant$<Snapshot(m_std$$option$$Option$_beg_$struct$m_specialized$$pclmulqdq$$State$_end_)>(snap$<Snapshot(m_std$$option$$Option$_beg_$struct$m_specialized$$pclmulqdq$$State$_end_)>(self))) == (__result)
{
	self.discriminant
}

method m_specialized$$pclmulqdq$$State$$new(...)
    returns (_0: Ref(m_std$$option$$Option$_beg_$struct$m_specialized$$pclmulqdq$$State$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Bool
    __t13: Bool
    __t14: Bool
    __t15: Bool
    __t16: Bool
    __t17: Bool
    _1: Ref(u32)
    _2: Ref(bool)
    _3: Ref(bool)
    _4: Ref(bool)
    _5: Ref(bool)
    _6: Ref(bool)
    _7: Ref(bool)
    _8: Ref(struct$m_specialized$$pclmulqdq$$State)
    _9: Ref(u32)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::specialized::pclmulqdq::{impl#0}::new"
    // Span: src/specialized/pclmulqdq.rs:27:5: 38:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    __t11 := copy false
    // Preconditions:
    inhale (acc(u32(_1), write)) && (true)
    inhale true
    inhale (true) && (true)
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l22
    // Fold predicates for &mut args and transfer borrow permissions to old
    // Fold the result
    obtain acc(m_std$$option$$Option$_beg_$struct$m_specialized$$pclmulqdq$$State$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale true
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_std$$option$$Option$_beg_$struct$m_specialized$$pclmulqdq$$State$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_2)
    // [mir] _2 = const false
    _2 := builtin$havoc_ref()
    inhale acc(_2.val_bool, write)
    _2.val_bool := copy false
    // [mir] switchInt(move _2) -> [0: bb1, otherwise: bb3]
    __t12 := copy _2.val_bool
    GotoSwitch([(UnaryOp(UnaryOp { op_kind: Not, argument: Local(Local { variable: __t12: Bool, position: Position { line: 0, column: 0, id: 0 } }), position: Position { line: 0, column: 0, id: 0 } }), cfg:4)], cfg:3)
  label l0 // 3
    // ========== l0 ==========
    // MIR edge bb0 --> bb3
    Goto(cfg:9)
  label l1 // 4
    // ========== l1 ==========
    // MIR edge bb0 --> bb1
    Goto(cfg:5)
  label bb1 // 5
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = std_detect::detect::arch::x86::__is_feature_detected::pclmulqdq() -> [return: bb2, unwind: bb12]
    label l2
    assert true
    assert true
    exhale true
    _3 := builtin$havoc_ref()
    inhale true
    inhale acc(bool(_3), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l3
    Goto(cfg:6)
  label bb2 // 6
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] switchInt(move _3) -> [0: bb10, otherwise: bb3]
    __t13 := copy _3.val_bool
    GotoSwitch([(UnaryOp(UnaryOp { op_kind: Not, argument: Local(Local { variable: __t13: Bool, position: Position { line: 0, column: 0, id: 0 } }), position: Position { line: 0, column: 0, id: 0 } }), cfg:8)], cfg:7)
  label l4 // 7
    // ========== l4 ==========
    // MIR edge bb2 --> bb3
    Goto(cfg:9)
  label l5 // 8
    // ========== l5 ==========
    // MIR edge bb2 --> bb10
    Goto(cfg:24)
  label bb3 // 9
    // ========== bb3 ==========
    __t3 := copy true
    // [mir] StorageLive(_4)
    // [mir] _4 = const true
    _4 := builtin$havoc_ref()
    inhale acc(_4.val_bool, write)
    _4.val_bool := copy true
    // [mir] switchInt(move _4) -> [0: bb4, otherwise: bb6]
    __t14 := copy _4.val_bool
    GotoSwitch([(UnaryOp(UnaryOp { op_kind: Not, argument: Local(Local { variable: __t14: Bool, position: Position { line: 0, column: 0, id: 0 } }), position: Position { line: 0, column: 0, id: 0 } }), cfg:11)], cfg:10)
  label l6 // 10
    // ========== l6 ==========
    // MIR edge bb3 --> bb6
    Goto(cfg:16)
  label l7 // 11
    // ========== l7 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:12)
  label bb4 // 12
    // ========== bb4 ==========
    __t4 := copy true
    // [mir] StorageLive(_5)
    // [mir] _5 = std_detect::detect::arch::x86::__is_feature_detected::sse2() -> [return: bb5, unwind: bb12]
    label l8
    assert true
    assert true
    exhale true
    _5 := builtin$havoc_ref()
    inhale true
    inhale acc(bool(_5), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l9
    Goto(cfg:13)
  label bb5 // 13
    // ========== bb5 ==========
    __t5 := copy true
    // [mir] switchInt(move _5) -> [0: bb10, otherwise: bb6]
    __t15 := copy _5.val_bool
    GotoSwitch([(UnaryOp(UnaryOp { op_kind: Not, argument: Local(Local { variable: __t15: Bool, position: Position { line: 0, column: 0, id: 0 } }), position: Position { line: 0, column: 0, id: 0 } }), cfg:15)], cfg:14)
  label l10 // 14
    // ========== l10 ==========
    // MIR edge bb5 --> bb6
    Goto(cfg:16)
  label l11 // 15
    // ========== l11 ==========
    // MIR edge bb5 --> bb10
    Goto(cfg:24)
  label bb6 // 16
    // ========== bb6 ==========
    __t6 := copy true
    // [mir] StorageLive(_6)
    // [mir] _6 = const false
    _6 := builtin$havoc_ref()
    inhale acc(_6.val_bool, write)
    _6.val_bool := copy false
    // [mir] switchInt(move _6) -> [0: bb7, otherwise: bb9]
    __t16 := copy _6.val_bool
    GotoSwitch([(Local(Local { variable: __t16: Bool, position: Position { line: 0, column: 0, id: 0 } }), cfg:18)], cfg:17)
  label l12 // 17
    // ========== l12 ==========
    // MIR edge bb6 --> bb7
    Goto(cfg:19)
  label l13 // 18
    // ========== l13 ==========
    // MIR edge bb6 --> bb9
    Goto(cfg:23)
  label bb7 // 19
    // ========== bb7 ==========
    __t7 := copy true
    // [mir] StorageLive(_7)
    // [mir] _7 = std_detect::detect::arch::x86::__is_feature_detected::sse4_1() -> [return: bb8, unwind: bb12]
    label l14
    assert true
    assert true
    exhale true
    _7 := builtin$havoc_ref()
    inhale true
    inhale acc(bool(_7), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l15
    Goto(cfg:20)
  label bb8 // 20
    // ========== bb8 ==========
    __t8 := copy true
    // [mir] switchInt(move _7) -> [0: bb10, otherwise: bb9]
    __t17 := copy _7.val_bool
    GotoSwitch([(UnaryOp(UnaryOp { op_kind: Not, argument: Local(Local { variable: __t17: Bool, position: Position { line: 0, column: 0, id: 0 } }), position: Position { line: 0, column: 0, id: 0 } }), cfg:22)], cfg:21)
  label l16 // 21
    // ========== l16 ==========
    // MIR edge bb8 --> bb9
    Goto(cfg:23)
  label l17 // 22
    // ========== l17 ==========
    // MIR edge bb8 --> bb10
    Goto(cfg:24)
  label bb9 // 23
    // ========== bb9 ==========
    __t9 := copy true
    // [mir] StorageLive(_8)
    // [mir] StorageLive(_9)
    // [mir] _9 = _1
    _9 := builtin$havoc_ref()
    inhale acc(_9.val_int, write)
    _9.val_int := copy _1.val_int
    label l18
    // [mir] _8 = specialized::pclmulqdq::State { state: move _9 }
    _8 := builtin$havoc_ref()
    inhale acc(struct$m_specialized$$pclmulqdq$$State(_8), write)
    _8.f$state := move _9
    label l19
    // [mir] StorageDead(_9)
    // [mir] _0 = std::option::Option::<specialized::pclmulqdq::State>::Some(move _8)
    _0 := builtin$havoc_ref()
    inhale acc(m_std$$option$$Option$_beg_$struct$m_specialized$$pclmulqdq$$State$_end_(_0), write)
    inhale (m_std$$option$$Option$_beg_$struct$m_specialized$$pclmulqdq$$State$_end_$$discriminant$$<>(_0)) == (1)
    downcast _0 to enum_Some

    _0[enum_Some].f$0 := move _8
    label l20
    // [mir] StorageDead(_8)
    // [mir] goto -> bb11
    Goto(cfg:25)
  label bb10 // 24
    // ========== bb10 ==========
    __t10 := copy true
    // [mir] _0 = std::option::Option::<specialized::pclmulqdq::State>::None
    _0 := builtin$havoc_ref()
    inhale acc(m_std$$option$$Option$_beg_$struct$m_specialized$$pclmulqdq$$State$_end_(_0), write)
    inhale (m_std$$option$$Option$_beg_$struct$m_specialized$$pclmulqdq$$State$_end_$$discriminant$$<>(_0)) == (0)
    // [mir] goto -> bb11
    Goto(cfg:25)
  label bb11 // 25
    // ========== bb11 ==========
    __t11 := copy true
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_6)
    // [mir] StorageDead(_5)
    // [mir] StorageDead(_4)
    // [mir] StorageDead(_3)
    // [mir] StorageDead(_2)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_specialized$$pclmulqdq$$State$$update(...)
    returns (_0: Ref(tuple0$))
{
    __t0: Bool
    __t1: Bool
    _old$pre$0: Ref(struct$m_specialized$$pclmulqdq$$State)
    _old$pre$1: Ref(Slice$u8)
    _1: Ref(ref$struct$m_specialized$$pclmulqdq$$State)
    _2: Ref(ref$Slice$u8)
    _3: Ref(u32)
    _4: Ref(u32)
    _5: Ref(ref$Slice$u8)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::specialized::pclmulqdq::{impl#0}::update"
    // Span: src/specialized/pclmulqdq.rs:40:5: 44:6 (#0)
    __t0 := copy false
    __t1 := copy false
    // Preconditions:
    inhale (acc(_1.val_ref, write)) && ((acc(struct$m_specialized$$pclmulqdq$$State(_1.val_ref), write)) && ((acc(_2.val_ref, write)) && ((acc(Slice$u8(_2.val_ref), read)) && (true))))
    inhale true
    inhale (true) && ((true) && (true))
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l7
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(struct$m_specialized$$pclmulqdq$$State(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(Slice$u8(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(tuple0$(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && ((true) && (true))
    // Exhale permissions of postcondition (1/3)
    exhale (acc(struct$m_specialized$$pclmulqdq$$State(_old$pre$0), write)) && ((acc(Slice$u8(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(tuple0$(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] _4 = ((*_1).0: u32)
    _4 := builtin$havoc_ref()
    inhale acc(_4.val_int, write)
    _4.val_int := copy _1.val_ref.f$state.val_int
    label l0
    // [mir] StorageLive(_5)
    // [mir] _5 = &'?4 (*_2)
    _5 := builtin$havoc_ref()
    inhale acc(_5.val_ref, write)
    _5.val_ref := borrow _2.val_ref // L4
    label l1
    // [mir] _3 = specialized::pclmulqdq::calculate(move _4, move _5) -> [return: bb1, unwind: bb2]
    label l2
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(u32(_4), write)) && ((acc(_5.val_ref, write)) && ((true) && (true)))
    _3 := builtin$havoc_ref()
    inhale true
    inhale acc(u32(_3), write)
    transfer perm _5.val_ref --> old[l2](_5.val_ref) // unchecked: true
    inhale (true) && (true)
    inhale true
    exhale true
    label l3
    Goto(cfg:3)
  label l4 // 3
    // ========== l4 ==========
    // MIR edge bb0 --> bb1
    // Expire borrows
    expire_borrows ReborrowingDAG(L5,L4,)

    Goto(cfg:4)
  label bb1 // 4
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_5)
    // [mir] StorageDead(_4)
    // [mir] ((*_1).0: u32) = move _3
    _1.val_ref.f$state := move _3
    label l5
    // [mir] _0 = const ()
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_specialized$$pclmulqdq$$State$$finalize(...)
    returns (_0: Ref(u32))
{
    __t0: Bool
    _1: Ref(struct$m_specialized$$pclmulqdq$$State)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::specialized::pclmulqdq::{impl#0}::finalize"
    // Span: src/specialized/pclmulqdq.rs:46:5: 48:6 (#0)
    __t0 := copy false
    // Preconditions:
    inhale (acc(struct$m_specialized$$pclmulqdq$$State(_1), write)) && (true)
    inhale true
    inhale (true) && (true)
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l2
    // Fold predicates for &mut args and transfer borrow permissions to old
    // Fold the result
    obtain acc(u32(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale true
    // Exhale permissions of postcondition (2/3)
    exhale acc(u32(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] _0 = (_1.0: u32)
    _0 := builtin$havoc_ref()
    inhale acc(_0.val_int, write)
    _0.val_int := copy _1.f$state.val_int
    label l0
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_specialized$$pclmulqdq$$State$$reset(...)
    returns (_0: Ref(tuple0$))
{
    __t0: Bool
    _old$pre$0: Ref(struct$m_specialized$$pclmulqdq$$State)
    _1: Ref(ref$struct$m_specialized$$pclmulqdq$$State)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::specialized::pclmulqdq::{impl#0}::reset"
    // Span: src/specialized/pclmulqdq.rs:50:5: 52:6 (#0)
    __t0 := copy false
    // Preconditions:
    inhale (acc(_1.val_ref, write)) && ((acc(struct$m_specialized$$pclmulqdq$$State(_1.val_ref), write)) && (true))
    inhale true
    inhale (true) && (true)
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l1
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(struct$m_specialized$$pclmulqdq$$State(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(tuple0$(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && ((true) && (true))
    // Exhale permissions of postcondition (1/3)
    exhale (acc(struct$m_specialized$$pclmulqdq$$State(_old$pre$0), write)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(tuple0$(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] ((*_1).0: u32) = const 0_u32
    _1.val_ref.f$state.val_int := copy 0
    // [mir] _0 = const ()
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_specialized$$pclmulqdq$$State$$combine(...)
    returns (_0: Ref(tuple0$))
{
    __t0: Bool
    __t1: Bool
    _old$pre$0: Ref(struct$m_specialized$$pclmulqdq$$State)
    _1: Ref(ref$struct$m_specialized$$pclmulqdq$$State)
    _2: Ref(u32)
    _3: Ref(u64)
    _4: Ref(u32)
    _5: Ref(u32)
    _6: Ref(u32)
    _7: Ref(u64)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::specialized::pclmulqdq::{impl#0}::combine"
    // Span: src/specialized/pclmulqdq.rs:54:5: 56:6 (#0)
    __t0 := copy false
    __t1 := copy false
    // Preconditions:
    inhale (acc(_1.val_ref, write)) && ((acc(struct$m_specialized$$pclmulqdq$$State(_1.val_ref), write)) && ((acc(u32(_2), write)) && ((acc(u64(_3), write)) && (true))))
    inhale true
    inhale (true) && ((true) && ((true) && (true)))
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l7
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(struct$m_specialized$$pclmulqdq$$State(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(tuple0$(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && ((true) && (true))
    // Exhale permissions of postcondition (1/3)
    exhale (acc(struct$m_specialized$$pclmulqdq$$State(_old$pre$0), write)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(tuple0$(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_4)
    // [mir] StorageLive(_5)
    // [mir] _5 = ((*_1).0: u32)
    _5 := builtin$havoc_ref()
    inhale acc(_5.val_int, write)
    _5.val_int := copy _1.val_ref.f$state.val_int
    label l0
    // [mir] StorageLive(_6)
    // [mir] _6 = _2
    _6 := builtin$havoc_ref()
    inhale acc(_6.val_int, write)
    _6.val_int := copy _2.val_int
    label l1
    // [mir] StorageLive(_7)
    // [mir] _7 = _3
    _7 := builtin$havoc_ref()
    inhale acc(_7.val_int, write)
    _7.val_int := copy _3.val_int
    label l2
    // [mir] _4 = combine::combine(move _5, move _6, move _7) -> [return: bb1, unwind: bb2]
    label l3
    assert true
    assert (true) && ((true) && ((true) && (true)))
    exhale (acc(u32(_5), write)) && ((acc(u32(_6), write)) && ((acc(u64(_7), write)) && (true)))
    _4 := builtin$havoc_ref()
    inhale true
    inhale acc(u32(_4), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l4
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_6)
    // [mir] StorageDead(_5)
    // [mir] ((*_1).0: u32) = move _4
    _1.val_ref.f$state := move _4
    label l5
    // [mir] StorageDead(_4)
    // [mir] _0 = const ()
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


function m_State$_beg_$_end_$$discriminant$$<>(self: Ref(m_State$_beg_$_end_)): Int
  requires acc(m_State$_beg_$_end_(self), read)
  ensures (((0) <= (__result)) && ((__result) <= (1))) || (false)
  ensures (discriminant$<Snapshot(m_State$_beg_$_end_)>(snap$<Snapshot(m_State$_beg_$_end_)>(self))) == (__result)
{
	self.discriminant
}

method m_$openang$State$space$as$space$std$$clone$$Clone$closeang$$$clone(...)
    returns (_0: Ref(m_State$_beg_$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Int
    _old$pre$0: Ref(m_State$_beg_$_end_)
    _1: Ref(ref$m_State$_beg_$_end_)
    _2: Ref(isize)
    _3: Ref(ref$struct$m_baseline$$State)
    _4: Ref(struct$m_baseline$$State)
    _5: Ref(ref$struct$m_baseline$$State)
    _6: Ref(ref$struct$m_specialized$$pclmulqdq$$State)
    _7: Ref(struct$m_specialized$$pclmulqdq$$State)
    _8: Ref(ref$struct$m_specialized$$pclmulqdq$$State)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::{impl#4}::clone"
    // Span: src/lib.rs:46:10: 46:15 (#46)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    // Preconditions:
    inhale (acc(_1.val_ref, write)) && ((acc(m_State$_beg_$_end_(_1.val_ref), read)) && (true))
    inhale true
    inhale (true) && (true)
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l15
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(m_State$_beg_$_end_(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(m_State$_beg_$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(m_State$_beg_$_end_(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_State$_beg_$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] FakeRead(ForMatchedPlace(None), _1)
    // [mir] _2 = discriminant((*_1))
    _2 := builtin$havoc_ref()
    inhale acc(_2.val_int, write)
    _2.val_int := copy m_State$_beg_$_end_$$discriminant$$<>(_1.val_ref)
    // [mir] switchInt(move _2) -> [0: bb1, 1: bb2, otherwise: bb3]
    __t8 := copy _2.val_int
    // Ignore default target bb3, as the compiler marked it as unreachable.
    GotoSwitch([(BinOp(BinOp { op_kind: EqCmp, left: Local(Local { variable: __t8: Int, position: Position { line: 0, column: 0, id: 0 } }), right: Const(ConstExpr { value: BigInt("0"), position: Position { line: 0, column: 0, id: 0 } }), position: Position { line: 0, column: 0, id: 0 } }), cfg:4)], cfg:3)
  label l0 // 3
    // ========== l0 ==========
    // MIR edge bb0 --> bb2
    Goto(cfg:6)
  label l1 // 4
    // ========== l1 ==========
    // MIR edge bb0 --> bb1
    Goto(cfg:9)
  label bb3 // 5
    // ========== bb3 ==========
    __t1 := copy true
    // [mir] unreachable
    Return
  label bb2 // 6
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] StorageLive(_6)
    // [mir] _6 = &'?3 (((*_1) as Specialized).0: specialized::pclmulqdq::State)
    _6 := builtin$havoc_ref()
    inhale acc(_6.val_ref, write)
    _6.val_ref := borrow _1.val_ref[enum_Specialized].f$0 // L3
    label l2
    // [mir] StorageLive(_7)
    // [mir] StorageLive(_8)
    // [mir] _8 = &'?4 (*_6)
    _8 := builtin$havoc_ref()
    inhale acc(_8.val_ref, write)
    _8.val_ref := borrow _6.val_ref // L6
    label l3
    // [mir] _7 = <specialized::pclmulqdq::State as std::clone::Clone>::clone(move _8) -> [return: bb6, unwind: bb8]
    label l4
    assert true
    assert (true) && (true)
    exhale (acc(_8.val_ref, write)) && ((true) && (true))
    _7 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_specialized$$pclmulqdq$$State(_7), write)
    transfer perm _8.val_ref --> old[l4](_8.val_ref) // unchecked: true
    inhale (true) && (true)
    inhale true
    exhale true
    label l5
    Goto(cfg:7)
  label l6 // 7
    // ========== l6 ==========
    // MIR edge bb2 --> bb6
    // Expire borrows
    expire_borrows ReborrowingDAG(L8,L6,L3,)

    Goto(cfg:8)
  label bb6 // 8
    // ========== bb6 ==========
    __t3 := copy true
    // [mir] StorageDead(_8)
    // [mir] _0 = State::Specialized(move _7)
    _0 := builtin$havoc_ref()
    inhale acc(m_State$_beg_$_end_(_0), write)
    inhale (m_State$_beg_$_end_$$discriminant$$<>(_0)) == (1)
    downcast _0 to enum_Specialized

    _0[enum_Specialized].f$0 := move _7
    label l7
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_6)
    // [mir] goto -> bb7
    Goto(cfg:13)
  label bb1 // 9
    // ========== bb1 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb4, imaginary: bb2]
    Goto(cfg:10)
  label bb4 // 10
    // ========== bb4 ==========
    __t5 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = &'?5 (((*_1) as Baseline).0: baseline::State)
    _3 := builtin$havoc_ref()
    inhale acc(_3.val_ref, write)
    _3.val_ref := borrow _1.val_ref[enum_Baseline].f$0 // L7
    label l8
    // [mir] StorageLive(_4)
    // [mir] StorageLive(_5)
    // [mir] _5 = &'?6 (*_3)
    _5 := builtin$havoc_ref()
    inhale acc(_5.val_ref, write)
    _5.val_ref := borrow _3.val_ref // L5
    label l9
    // [mir] _4 = <baseline::State as std::clone::Clone>::clone(move _5) -> [return: bb5, unwind: bb8]
    label l10
    assert true
    assert (true) && (true)
    exhale (acc(_5.val_ref, write)) && ((true) && (true))
    _4 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_baseline$$State(_4), write)
    transfer perm _5.val_ref --> old[l10](_5.val_ref) // unchecked: true
    inhale (true) && (true)
    inhale true
    exhale true
    label l11
    Goto(cfg:11)
  label l12 // 11
    // ========== l12 ==========
    // MIR edge bb4 --> bb5
    // Expire borrows
    expire_borrows ReborrowingDAG(L4,L5,L7,)

    Goto(cfg:12)
  label bb5 // 12
    // ========== bb5 ==========
    __t6 := copy true
    // [mir] StorageDead(_5)
    // [mir] _0 = State::Baseline(move _4)
    _0 := builtin$havoc_ref()
    inhale acc(m_State$_beg_$_end_(_0), write)
    inhale (m_State$_beg_$_end_$$discriminant$$<>(_0)) == (0)
    downcast _0 to enum_Baseline

    _0[enum_Baseline].f$0 := move _4
    label l13
    // [mir] StorageDead(_4)
    // [mir] StorageDead(_3)
    // [mir] goto -> bb7
    Goto(cfg:13)
  label bb7 // 13
    // ========== bb7 ==========
    __t7 := copy true
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_$openang$Hasher$space$as$space$std$$clone$$Clone$closeang$$$clone(...)
    returns (_0: Ref(struct$m_Hasher))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    _old$pre$0: Ref(struct$m_Hasher)
    _1: Ref(ref$struct$m_Hasher)
    _2: Ref(u64)
    _3: Ref(ref$u64)
    _4: Ref(ref$u64)
    _5: Ref(m_State$_beg_$_end_)
    _6: Ref(ref$m_State$_beg_$_end_)
    _7: Ref(ref$m_State$_beg_$_end_)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::{impl#5}::clone"
    // Span: src/lib.rs:52:10: 52:15 (#47)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    // Preconditions:
    inhale (acc(_1.val_ref, write)) && ((acc(struct$m_Hasher(_1.val_ref), read)) && (true))
    inhale true
    inhale (true) && (true)
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l13
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(struct$m_Hasher(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(struct$m_Hasher(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(struct$m_Hasher(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(struct$m_Hasher(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_2)
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] _4 = &'?3 ((*_1).0: u64)
    _4 := builtin$havoc_ref()
    inhale acc(_4.val_ref, write)
    _4.val_ref := borrow _1.val_ref.f$amount // L4
    label l0
    // [mir] _3 = &'?4 (*_4)
    _3 := builtin$havoc_ref()
    inhale acc(_3.val_ref, write)
    _3.val_ref := borrow _4.val_ref // L6
    label l1
    // [mir] _2 = <u64 as std::clone::Clone>::clone(move _3) -> [return: bb1, unwind: bb3]
    label l2
    assert true
    assert (true) && (true)
    exhale (acc(_3.val_ref, write)) && ((true) && (true))
    _2 := builtin$havoc_ref()
    inhale true
    inhale acc(u64(_2), write)
    transfer perm _3.val_ref --> old[l2](_3.val_ref) // unchecked: true
    inhale (true) && (true)
    inhale true
    exhale true
    label l3
    Goto(cfg:3)
  label l4 // 3
    // ========== l4 ==========
    // MIR edge bb0 --> bb1
    // Expire borrows
    expire_borrows ReborrowingDAG(L8,L6,L4,)

    Goto(cfg:4)
  label bb1 // 4
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_3)
    // [mir] StorageLive(_5)
    // [mir] StorageLive(_6)
    // [mir] StorageLive(_7)
    // [mir] _7 = &'?5 ((*_1).1: State)
    _7 := builtin$havoc_ref()
    inhale acc(_7.val_ref, write)
    _7.val_ref := borrow _1.val_ref.f$state // L3
    label l5
    // [mir] _6 = &'?6 (*_7)
    _6 := builtin$havoc_ref()
    inhale acc(_6.val_ref, write)
    _6.val_ref := borrow _7.val_ref // L5
    label l6
    // [mir] _5 = <State as std::clone::Clone>::clone(move _6) -> [return: bb2, unwind: bb3]
    label l7
    assert true
    assert (true) && (true)
    exhale (acc(_6.val_ref, write)) && ((true) && (true))
    _5 := builtin$havoc_ref()
    inhale true
    inhale acc(m_State$_beg_$_end_(_5), write)
    transfer perm _6.val_ref --> old[l7](_6.val_ref) // unchecked: true
    inhale (true) && (true)
    inhale true
    exhale true
    label l8
    Goto(cfg:5)
  label l9 // 5
    // ========== l9 ==========
    // MIR edge bb1 --> bb2
    // Expire borrows
    expire_borrows ReborrowingDAG(L7,L5,L3,)

    Goto(cfg:6)
  label bb2 // 6
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] StorageDead(_6)
    // [mir] _0 = Hasher { amount: move _2, state: move _5 }
    _0 := builtin$havoc_ref()
    inhale acc(struct$m_Hasher(_0), write)
    _0.f$amount := move _2
    label l10
    _0.f$state := move _5
    label l11
    // [mir] StorageDead(_5)
    // [mir] StorageDead(_2)
    // [mir] StorageDead(_7)
    // [mir] StorageDead(_4)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_Hasher$$new(...)
    returns (_0: Ref(struct$m_Hasher))
{
    __t0: Bool
    __t1: Bool
    _t1: Ref(u32)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::{impl#0}::new"
    // Span: src/lib.rs:66:5: 68:6 (#0)
    __t0 := copy false
    __t1 := copy false
    // Preconditions:
    inhale true
    inhale true
    inhale true
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l3
    // Fold predicates for &mut args and transfer borrow permissions to old
    // Fold the result
    obtain acc(struct$m_Hasher(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale true
    // Exhale permissions of postcondition (2/3)
    exhale acc(struct$m_Hasher(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] _0 = Hasher::new_with_initial(const _) -> [return: bb1, unwind: bb2]
    label l0
    _t1 := builtin$havoc_ref()
    inhale acc(u32(_t1), write)
    assert true
    assert (true) && (true)
    exhale (acc(u32(_t1), write)) && (true)
    _0 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_Hasher(_0), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_Hasher$$new_with_initial(...)
    returns (_0: Ref(struct$m_Hasher))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    _aux_havoc_ref$u32: Ref(ref$u32)
    _1: Ref(u32)
    _2: Ref(m_std$$option$$Option$_beg_$struct$m_Hasher$_end_)
    _3: Ref(u32)
    _4: Ref(closure$m_Hasher$$new_with_initial$$$opencur$closure$sharp$0$closecur$)
    _5: Ref(ref$u32)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::{impl#0}::new_with_initial"
    // Span: src/lib.rs:74:5: 76:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    // Preconditions:
    inhale (acc(u32(_1), write)) && (true)
    inhale true
    inhale (true) && (true)
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l9
    // Fold predicates for &mut args and transfer borrow permissions to old
    // Fold the result
    obtain acc(struct$m_Hasher(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale true
    // Exhale permissions of postcondition (2/3)
    exhale acc(struct$m_Hasher(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_2)
    // [mir] StorageLive(_3)
    // [mir] _3 = _1
    _3 := builtin$havoc_ref()
    inhale acc(_3.val_int, write)
    _3.val_int := copy _1.val_int
    label l0
    // [mir] _2 = Hasher::internal_new_specialized(move _3) -> [return: bb1, unwind: bb3]
    label l1
    assert true
    assert (true) && (true)
    exhale (acc(u32(_3), write)) && (true)
    _2 := builtin$havoc_ref()
    inhale true
    inhale acc(m_std$$option$$Option$_beg_$struct$m_Hasher$_end_(_2), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l2
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_3)
    // [mir] StorageLive(_4)
    // [mir] StorageLive(_5)
    // [mir] _5 = &'?2 _1
    _5 := builtin$havoc_ref()
    inhale acc(_5.val_ref, write)
    _5.val_ref := borrow _1 // L0
    label l3
    // [mir] _4 = [closure@src/lib.rs:75:61: 75:63] { init: move _5 }
    _4 := builtin$havoc_ref()
    inhale acc(closure$m_Hasher$$new_with_initial$$$opencur$closure$sharp$0$closecur$(_4), write)
    _aux_havoc_ref$u32 := builtin$havoc_ref()
    _4.closure_0 := move _aux_havoc_ref$u32
    inhale acc(_4.closure_0.val_ref, write)
    _4.closure_0.val_ref := move _5.val_ref
    label l4
    // [mir] StorageDead(_5)
    // [mir] _0 = std::option::Option::<Hasher>::unwrap_or_else::<[closure@src/lib.rs:75:61: 75:63]>(move _2, move _4) -> [return: bb2, unwind: bb3]
    label l5
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(m_std$$option$$Option$_beg_$struct$m_Hasher$_end_(_2), write)) && ((acc(closure$m_Hasher$$new_with_initial$$$opencur$closure$sharp$0$closecur$(_4), write)) && (true))
    _0 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_Hasher(_0), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l6
    Goto(cfg:4)
  label l7 // 4
    // ========== l7 ==========
    // MIR edge bb1 --> bb2
    // Expire borrows
    expire_borrows ReborrowingDAG(L0,)

    Goto(cfg:5)
  label bb2 // 5
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] StorageDead(_4)
    // [mir] StorageDead(_2)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_Hasher$$new_with_initial(...)
    returns (_0: Ref(struct$m_Hasher))
{
  label stub // 0
    // ========== stub ==========
    // Def path: "crc32fast::{impl#0}::new_with_initial"
    // Span: src/lib.rs:74:5: 76:6 (#0)
    Return
  label end_of_method
}


method m_Hasher$$internal_new_baseline(...)
    returns (_0: Ref(struct$m_Hasher))
{
    __t0: Bool
    __t1: Bool
    _aux_havoc_u64: Ref(u64)
    _1: Ref(u32)
    _2: Ref(m_State$_beg_$_end_)
    _3: Ref(struct$m_baseline$$State)
    _4: Ref(u32)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::{impl#0}::internal_new_baseline"
    // Span: src/lib.rs:80:5: 85:6 (#0)
    __t0 := copy false
    __t1 := copy false
    // Preconditions:
    inhale (acc(u32(_1), write)) && (true)
    inhale true
    inhale (true) && (true)
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l6
    // Fold predicates for &mut args and transfer borrow permissions to old
    // Fold the result
    obtain acc(struct$m_Hasher(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale true
    // Exhale permissions of postcondition (2/3)
    exhale acc(struct$m_Hasher(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_2)
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] _4 = _1
    _4 := builtin$havoc_ref()
    inhale acc(_4.val_int, write)
    _4.val_int := copy _1.val_int
    label l0
    // [mir] _3 = baseline::State::new(move _4) -> [return: bb1, unwind: bb2]
    label l1
    assert true
    assert (true) && (true)
    exhale (acc(u32(_4), write)) && (true)
    _3 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_baseline$$State(_3), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l2
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_4)
    // [mir] _2 = State::Baseline(move _3)
    _2 := builtin$havoc_ref()
    inhale acc(m_State$_beg_$_end_(_2), write)
    inhale (m_State$_beg_$_end_$$discriminant$$<>(_2)) == (0)
    downcast _2 to enum_Baseline

    _2[enum_Baseline].f$0 := move _3
    label l3
    // [mir] StorageDead(_3)
    // [mir] _0 = Hasher { amount: const 0_u64, state: move _2 }
    _0 := builtin$havoc_ref()
    inhale acc(struct$m_Hasher(_0), write)
    _aux_havoc_u64 := builtin$havoc_ref()
    _0.f$amount := move _aux_havoc_u64
    inhale acc(_0.f$amount.val_int, write)
    _0.f$amount.val_int := copy 0
    _0.f$state := move _2
    label l4
    // [mir] StorageDead(_2)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


function m_std$$option$$Option$_beg_$struct$m_Hasher$_end_$$discriminant$$<>(self: Ref(m_std$$option$$Option$_beg_$struct$m_Hasher$_end_)): Int
  requires acc(m_std$$option$$Option$_beg_$struct$m_Hasher$_end_(self), read)
  ensures (((0) <= (__result)) && ((__result) <= (1))) || (false)
  ensures (discriminant$<Snapshot(m_std$$option$$Option$_beg_$struct$m_Hasher$_end_)>(snap$<Snapshot(m_std$$option$$Option$_beg_$struct$m_Hasher$_end_)>(self))) == (__result)
{
	self.discriminant
}

method m_Hasher$$internal_new_specialized(...)
    returns (_0: Ref(m_std$$option$$Option$_beg_$struct$m_Hasher$_end_))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Int
    _aux_havoc_u64: Ref(u64)
    _1: Ref(u32)
    _2: Ref(tuple0$)
    _3: Ref(m_std$$option$$Option$_beg_$struct$m_specialized$$pclmulqdq$$State$_end_)
    _4: Ref(u32)
    _5: Ref(isize)
    _6: Ref(struct$m_specialized$$pclmulqdq$$State)
    _7: Ref(Never)
    _8: Ref(struct$m_Hasher)
    _9: Ref(m_State$_beg_$_end_)
    _10: Ref(struct$m_specialized$$pclmulqdq$$State)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::{impl#0}::internal_new_specialized"
    // Span: src/lib.rs:89:5: 99:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    // Preconditions:
    inhale (acc(u32(_1), write)) && (true)
    inhale true
    inhale (true) && (true)
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l11
    // Fold predicates for &mut args and transfer borrow permissions to old
    // Fold the result
    obtain acc(m_std$$option$$Option$_beg_$struct$m_Hasher$_end_(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale true
    // Exhale permissions of postcondition (2/3)
    exhale acc(m_std$$option$$Option$_beg_$struct$m_Hasher$_end_(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_2)
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] _4 = _1
    _4 := builtin$havoc_ref()
    inhale acc(_4.val_int, write)
    _4.val_int := copy _1.val_int
    label l0
    // [mir] _3 = specialized::pclmulqdq::State::new(move _4) -> [return: bb1, unwind: bb6]
    label l1
    assert true
    assert (true) && (true)
    exhale (acc(u32(_4), write)) && (true)
    _3 := builtin$havoc_ref()
    inhale true
    inhale acc(m_std$$option$$Option$_beg_$struct$m_specialized$$pclmulqdq$$State$_end_(_3), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l2
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_4)
    // [mir] FakeRead(ForMatchedPlace(None), _3)
    // [mir] _5 = discriminant(_3)
    _5 := builtin$havoc_ref()
    inhale acc(_5.val_int, write)
    _5.val_int := copy m_std$$option$$Option$_beg_$struct$m_specialized$$pclmulqdq$$State$_end_$$discriminant$$<>(_3)
    // [mir] switchInt(move _5) -> [1: bb2, otherwise: bb4]
    __t6 := copy _5.val_int
    GotoSwitch([(BinOp(BinOp { op_kind: EqCmp, left: Local(Local { variable: __t6: Int, position: Position { line: 0, column: 0, id: 0 } }), right: Const(ConstExpr { value: BigInt("1"), position: Position { line: 0, column: 0, id: 0 } }), position: Position { line: 0, column: 0, id: 0 } }), cfg:5)], cfg:4)
  label l3 // 4
    // ========== l3 ==========
    // MIR edge bb1 --> bb4
    Goto(cfg:6)
  label l4 // 5
    // ========== l4 ==========
    // MIR edge bb1 --> bb2
    Goto(cfg:7)
  label bb4 // 6
    // ========== bb4 ==========
    __t2 := copy true
    // [mir] _2 = const ()
    // [mir] StorageDead(_3)
    // [mir] StorageDead(_2)
    // [mir] _0 = std::option::Option::<Hasher>::None
    _0 := builtin$havoc_ref()
    inhale acc(m_std$$option$$Option$_beg_$struct$m_Hasher$_end_(_0), write)
    inhale (m_std$$option$$Option$_beg_$struct$m_Hasher$_end_$$discriminant$$<>(_0)) == (0)
    // [mir] goto -> bb5
    Goto(cfg:9)
  label bb2 // 7
    // ========== bb2 ==========
    __t3 := copy true
    // [mir] falseEdge -> [real: bb3, imaginary: bb4]
    Goto(cfg:8)
  label bb3 // 8
    // ========== bb3 ==========
    __t4 := copy true
    // [mir] StorageLive(_6)
    // [mir] _6 = move ((_3 as Some).0: specialized::pclmulqdq::State)
    _6 := move _3[enum_Some].f$0
    label l5
    // [mir] StorageLive(_8)
    // [mir] StorageLive(_9)
    // [mir] StorageLive(_10)
    // [mir] _10 = move _6
    _10 := move _6
    label l6
    // [mir] _9 = State::Specialized(move _10)
    _9 := builtin$havoc_ref()
    inhale acc(m_State$_beg_$_end_(_9), write)
    inhale (m_State$_beg_$_end_$$discriminant$$<>(_9)) == (1)
    downcast _9 to enum_Specialized

    _9[enum_Specialized].f$0 := move _10
    label l7
    // [mir] StorageDead(_10)
    // [mir] _8 = Hasher { amount: const 0_u64, state: move _9 }
    _8 := builtin$havoc_ref()
    inhale acc(struct$m_Hasher(_8), write)
    _aux_havoc_u64 := builtin$havoc_ref()
    _8.f$amount := move _aux_havoc_u64
    inhale acc(_8.f$amount.val_int, write)
    _8.f$amount.val_int := copy 0
    _8.f$state := move _9
    label l8
    // [mir] StorageDead(_9)
    // [mir] _0 = std::option::Option::<Hasher>::Some(move _8)
    _0 := builtin$havoc_ref()
    inhale acc(m_std$$option$$Option$_beg_$struct$m_Hasher$_end_(_0), write)
    inhale (m_std$$option$$Option$_beg_$struct$m_Hasher$_end_$$discriminant$$<>(_0)) == (1)
    downcast _0 to enum_Some

    _0[enum_Some].f$0 := move _8
    label l9
    // [mir] StorageDead(_8)
    // [mir] StorageDead(_6)
    // [mir] StorageDead(_3)
    // [mir] StorageDead(_2)
    // [mir] goto -> bb5
    Goto(cfg:9)
  label bb5 // 9
    // ========== bb5 ==========
    __t5 := copy true
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_Hasher$$update(...)
    returns (_0: Ref(tuple0$))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Int
    _old$pre$0: Ref(struct$m_Hasher)
    _old$pre$1: Ref(Slice$u8)
    _1: Ref(ref$struct$m_Hasher)
    _2: Ref(ref$Slice$u8)
    _3: Ref(u64)
    _4: Ref(usize)
    _5: Ref(ref$Slice$u8)
    _6: Ref(tuple2$u64$bool)
    _7: Ref(isize)
    _8: Ref(ref$struct$m_baseline$$State)
    _9: Ref(ref$struct$m_baseline$$State)
    _10: Ref(ref$Slice$u8)
    _11: Ref(ref$struct$m_specialized$$pclmulqdq$$State)
    _12: Ref(ref$struct$m_specialized$$pclmulqdq$$State)
    _13: Ref(ref$Slice$u8)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::{impl#0}::update"
    // Span: src/lib.rs:102:5: 108:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    // Preconditions:
    inhale (acc(_1.val_ref, write)) && ((acc(struct$m_Hasher(_1.val_ref), write)) && ((acc(_2.val_ref, write)) && ((acc(Slice$u8(_2.val_ref), read)) && (true))))
    inhale true
    inhale (true) && ((true) && (true))
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l19
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(struct$m_Hasher(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(Slice$u8(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(tuple0$(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && ((true) && (true))
    // Exhale permissions of postcondition (1/3)
    exhale (acc(struct$m_Hasher(_old$pre$0), write)) && ((acc(Slice$u8(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(tuple0$(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] StorageLive(_5)
    // [mir] _5 = &'?4 (*_2)
    _5 := builtin$havoc_ref()
    inhale acc(_5.val_ref, write)
    _5.val_ref := borrow _2.val_ref // L12
    label l0
    // [mir] _4 = core::slice::<impl [u8]>::len(move _5) -> [return: bb1, unwind: bb10]
    label l1
    _4 := builtin$havoc_ref()
    inhale acc(_4.val_int, write)
    _4.val_int := copy Slice$len<Ref(u8)>(_5.val_ref)
    transfer perm _5.val_ref --> old[l1](_5.val_ref) // unchecked: false
    Goto(cfg:3)
  label l2 // 3
    // ========== l2 ==========
    // MIR edge bb0 --> bb1
    // Expire borrows
    expire_borrows ReborrowingDAG(L15,L12,)

    Goto(cfg:4)
  label bb1 // 4
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_5)
    // [mir] _3 = move _4 as u64 (IntToInt)
    _3 := builtin$havoc_ref()
    inhale acc(_3.val_int, write)
    _3.val_int := copy builtin$cast$usize$u64<>(_4.val_int)
    // [mir] StorageDead(_4)
    // [mir] _6 = CheckedAdd(((*_1).0: u64), _3)
    _6 := builtin$havoc_ref()
    inhale acc(_6.tuple_0, write)
    inhale acc(_6.tuple_0.val_int, write)
    inhale acc(_6.tuple_1, write)
    inhale acc(_6.tuple_1.val_bool, write)
    _6.tuple_0.val_int := copy (_1.val_ref.f$amount.val_int) + (_3.val_int)
    _6.tuple_1.val_bool := copy (((_1.val_ref.f$amount.val_int) + (_3.val_int)) < (0)) || (((_1.val_ref.f$amount.val_int) + (_3.val_int)) > (18446744073709551615))
    // [mir] assert(!move (_6.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).0: u64), move _3) -> [success: bb2, unwind: bb10]
    __t10 := copy _6.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert !(__t10)
    Goto(cfg:5)
  label bb2 // 5
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] ((*_1).0: u64) = move (_6.0: u64)
    _1.val_ref.f$amount := move _6.tuple_0
    label l3
    // [mir] StorageDead(_3)
    // [mir] FakeRead(ForMatchedPlace(None), ((*_1).1: State))
    // [mir] _7 = discriminant(((*_1).1: State))
    _7 := builtin$havoc_ref()
    inhale acc(_7.val_int, write)
    _7.val_int := copy m_State$_beg_$_end_$$discriminant$$<>(_1.val_ref.f$state)
    // [mir] switchInt(move _7) -> [0: bb3, 1: bb4, otherwise: bb5]
    __t11 := copy _7.val_int
    // Ignore default target bb5, as the compiler marked it as unreachable.
    GotoSwitch([(BinOp(BinOp { op_kind: EqCmp, left: Local(Local { variable: __t11: Int, position: Position { line: 0, column: 0, id: 0 } }), right: Const(ConstExpr { value: BigInt("0"), position: Position { line: 0, column: 0, id: 0 } }), position: Position { line: 0, column: 0, id: 0 } }), cfg:7)], cfg:6)
  label l4 // 6
    // ========== l4 ==========
    // MIR edge bb2 --> bb4
    Goto(cfg:9)
  label l5 // 7
    // ========== l5 ==========
    // MIR edge bb2 --> bb3
    Goto(cfg:12)
  label bb5 // 8
    // ========== bb5 ==========
    __t3 := copy true
    // [mir] unreachable
    Return
  label bb4 // 9
    // ========== bb4 ==========
    __t4 := copy true
    // [mir] StorageLive(_11)
    // [mir] _11 = &'?5 mut ((((*_1).1: State) as Specialized).0: specialized::pclmulqdq::State)
    _11 := builtin$havoc_ref()
    inhale acc(_11.val_ref, write)
    _11.val_ref := mut borrow _1.val_ref.f$state[enum_Specialized].f$0 // L0
    label l6
    // [mir] StorageLive(_12)
    // [mir] _12 = &'?6 mut (*_11)
    _12 := builtin$havoc_ref()
    inhale acc(_12.val_ref, write)
    _12.val_ref := mut borrow _11.val_ref // L1
    label l7
    // [mir] StorageLive(_13)
    // [mir] _13 = &'?7 (*_2)
    _13 := builtin$havoc_ref()
    inhale acc(_13.val_ref, write)
    _13.val_ref := borrow _2.val_ref // L13
    label l8
    // [mir] _0 = specialized::pclmulqdq::State::update(move _12, move _13) -> [return: bb8, unwind: bb10]
    label l9
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(_12.val_ref, write)) && ((acc(struct$m_specialized$$pclmulqdq$$State(_12.val_ref), write)) && ((acc(_13.val_ref, write)) && ((true) && (true))))
    _0 := builtin$havoc_ref()
    inhale (acc(struct$m_specialized$$pclmulqdq$$State(old[l9](_12.val_ref)), write)) && (true)
    inhale acc(tuple0$(_0), write)
    transfer perm _13.val_ref --> old[l9](_13.val_ref) // unchecked: true
    inhale (true) && ((true) && (true))
    inhale true
    exhale true
    label l10
    Goto(cfg:10)
  label l11 // 10
    // ========== l11 ==========
    // MIR edge bb4 --> bb8
    // Expire borrows
    expire_borrows ReborrowingDAG(L9,L13,L8,L1,L0,)

    Goto(cfg:11)
  label bb8 // 11
    // ========== bb8 ==========
    __t5 := copy true
    // [mir] StorageDead(_13)
    // [mir] StorageDead(_12)
    // [mir] StorageDead(_11)
    // [mir] goto -> bb9
    Goto(cfg:16)
  label bb3 // 12
    // ========== bb3 ==========
    __t6 := copy true
    // [mir] falseEdge -> [real: bb6, imaginary: bb4]
    Goto(cfg:13)
  label bb6 // 13
    // ========== bb6 ==========
    __t7 := copy true
    // [mir] StorageLive(_8)
    // [mir] _8 = &'?8 mut ((((*_1).1: State) as Baseline).0: baseline::State)
    _8 := builtin$havoc_ref()
    inhale acc(_8.val_ref, write)
    _8.val_ref := mut borrow _1.val_ref.f$state[enum_Baseline].f$0 // L2
    label l12
    // [mir] StorageLive(_9)
    // [mir] _9 = &'?9 mut (*_8)
    _9 := builtin$havoc_ref()
    inhale acc(_9.val_ref, write)
    _9.val_ref := mut borrow _8.val_ref // L3
    label l13
    // [mir] StorageLive(_10)
    // [mir] _10 = &'?10 (*_2)
    _10 := builtin$havoc_ref()
    inhale acc(_10.val_ref, write)
    _10.val_ref := borrow _2.val_ref // L14
    label l14
    // [mir] _0 = baseline::State::update(move _9, move _10) -> [return: bb7, unwind: bb10]
    label l15
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(_9.val_ref, write)) && ((acc(struct$m_baseline$$State(_9.val_ref), write)) && ((acc(_10.val_ref, write)) && ((true) && (true))))
    _0 := builtin$havoc_ref()
    inhale (acc(struct$m_baseline$$State(old[l15](_9.val_ref)), write)) && (true)
    inhale acc(tuple0$(_0), write)
    transfer perm _10.val_ref --> old[l15](_10.val_ref) // unchecked: true
    inhale (true) && ((true) && (true))
    inhale true
    exhale true
    label l16
    Goto(cfg:14)
  label l17 // 14
    // ========== l17 ==========
    // MIR edge bb6 --> bb7
    // Expire borrows
    expire_borrows ReborrowingDAG(L11,L14,L10,L3,L2,)

    Goto(cfg:15)
  label bb7 // 15
    // ========== bb7 ==========
    __t8 := copy true
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] StorageDead(_8)
    // [mir] goto -> bb9
    Goto(cfg:16)
  label bb9 // 16
    // ========== bb9 ==========
    __t9 := copy true
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_Hasher$$finalize(...)
    returns (_0: Ref(u32))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Int
    _1: Ref(struct$m_Hasher)
    _2: Ref(isize)
    _3: Ref(struct$m_baseline$$State)
    _4: Ref(struct$m_baseline$$State)
    _5: Ref(struct$m_specialized$$pclmulqdq$$State)
    _6: Ref(struct$m_specialized$$pclmulqdq$$State)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::{impl#0}::finalize"
    // Span: src/lib.rs:111:5: 116:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    // Preconditions:
    inhale (acc(struct$m_Hasher(_1), write)) && (true)
    inhale true
    inhale (true) && (true)
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l11
    // Fold predicates for &mut args and transfer borrow permissions to old
    // Fold the result
    obtain acc(u32(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale true
    // Exhale permissions of postcondition (2/3)
    exhale acc(u32(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] FakeRead(ForMatchedPlace(None), (_1.1: State))
    // [mir] _2 = discriminant((_1.1: State))
    _2 := builtin$havoc_ref()
    inhale acc(_2.val_int, write)
    _2.val_int := copy m_State$_beg_$_end_$$discriminant$$<>(_1.f$state)
    // [mir] switchInt(move _2) -> [0: bb1, 1: bb2, otherwise: bb3]
    __t8 := copy _2.val_int
    // Ignore default target bb3, as the compiler marked it as unreachable.
    GotoSwitch([(BinOp(BinOp { op_kind: EqCmp, left: Local(Local { variable: __t8: Int, position: Position { line: 0, column: 0, id: 0 } }), right: Const(ConstExpr { value: BigInt("0"), position: Position { line: 0, column: 0, id: 0 } }), position: Position { line: 0, column: 0, id: 0 } }), cfg:4)], cfg:3)
  label l0 // 3
    // ========== l0 ==========
    // MIR edge bb0 --> bb2
    Goto(cfg:6)
  label l1 // 4
    // ========== l1 ==========
    // MIR edge bb0 --> bb1
    Goto(cfg:8)
  label bb3 // 5
    // ========== bb3 ==========
    __t1 := copy true
    // [mir] unreachable
    Return
  label bb2 // 6
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] StorageLive(_5)
    // [mir] _5 = move (((_1.1: State) as Specialized).0: specialized::pclmulqdq::State)
    _5 := move _1.f$state[enum_Specialized].f$0
    label l2
    // [mir] StorageLive(_6)
    // [mir] _6 = move _5
    _6 := move _5
    label l3
    // [mir] _0 = specialized::pclmulqdq::State::finalize(move _6) -> [return: bb6, unwind: bb8]
    label l4
    assert true
    assert (true) && (true)
    exhale (acc(struct$m_specialized$$pclmulqdq$$State(_6), write)) && (true)
    _0 := builtin$havoc_ref()
    inhale true
    inhale acc(u32(_0), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l5
    Goto(cfg:7)
  label bb6 // 7
    // ========== bb6 ==========
    __t3 := copy true
    // [mir] StorageDead(_6)
    // [mir] StorageDead(_5)
    // [mir] goto -> bb7
    Goto(cfg:11)
  label bb1 // 8
    // ========== bb1 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb4, imaginary: bb2]
    Goto(cfg:9)
  label bb4 // 9
    // ========== bb4 ==========
    __t5 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = move (((_1.1: State) as Baseline).0: baseline::State)
    _3 := move _1.f$state[enum_Baseline].f$0
    label l6
    // [mir] StorageLive(_4)
    // [mir] _4 = move _3
    _4 := move _3
    label l7
    // [mir] _0 = baseline::State::finalize(move _4) -> [return: bb5, unwind: bb8]
    label l8
    assert true
    assert (true) && (true)
    exhale (acc(struct$m_baseline$$State(_4), write)) && (true)
    _0 := builtin$havoc_ref()
    inhale true
    inhale acc(u32(_0), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l9
    Goto(cfg:10)
  label bb5 // 10
    // ========== bb5 ==========
    __t6 := copy true
    // [mir] StorageDead(_4)
    // [mir] StorageDead(_3)
    // [mir] goto -> bb7
    Goto(cfg:11)
  label bb7 // 11
    // ========== bb7 ==========
    __t7 := copy true
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_Hasher$$reset(...)
    returns (_0: Ref(tuple0$))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Int
    _old$pre$0: Ref(struct$m_Hasher)
    _1: Ref(ref$struct$m_Hasher)
    _2: Ref(isize)
    _3: Ref(ref$struct$m_baseline$$State)
    _4: Ref(ref$struct$m_baseline$$State)
    _5: Ref(ref$struct$m_specialized$$pclmulqdq$$State)
    _6: Ref(ref$struct$m_specialized$$pclmulqdq$$State)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::{impl#0}::reset"
    // Span: src/lib.rs:119:5: 125:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    // Preconditions:
    inhale (acc(_1.val_ref, write)) && ((acc(struct$m_Hasher(_1.val_ref), write)) && (true))
    inhale true
    inhale (true) && (true)
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l13
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(struct$m_Hasher(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(tuple0$(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && ((true) && (true))
    // Exhale permissions of postcondition (1/3)
    exhale (acc(struct$m_Hasher(_old$pre$0), write)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(tuple0$(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] ((*_1).0: u64) = const 0_u64
    _1.val_ref.f$amount.val_int := copy 0
    // [mir] FakeRead(ForMatchedPlace(None), ((*_1).1: State))
    // [mir] _2 = discriminant(((*_1).1: State))
    _2 := builtin$havoc_ref()
    inhale acc(_2.val_int, write)
    _2.val_int := copy m_State$_beg_$_end_$$discriminant$$<>(_1.val_ref.f$state)
    // [mir] switchInt(move _2) -> [0: bb1, 1: bb2, otherwise: bb3]
    __t8 := copy _2.val_int
    // Ignore default target bb3, as the compiler marked it as unreachable.
    GotoSwitch([(BinOp(BinOp { op_kind: EqCmp, left: Local(Local { variable: __t8: Int, position: Position { line: 0, column: 0, id: 0 } }), right: Const(ConstExpr { value: BigInt("0"), position: Position { line: 0, column: 0, id: 0 } }), position: Position { line: 0, column: 0, id: 0 } }), cfg:4)], cfg:3)
  label l0 // 3
    // ========== l0 ==========
    // MIR edge bb0 --> bb2
    Goto(cfg:6)
  label l1 // 4
    // ========== l1 ==========
    // MIR edge bb0 --> bb1
    Goto(cfg:9)
  label bb3 // 5
    // ========== bb3 ==========
    __t1 := copy true
    // [mir] unreachable
    Return
  label bb2 // 6
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] StorageLive(_5)
    // [mir] _5 = &'?3 mut ((((*_1).1: State) as Specialized).0: specialized::pclmulqdq::State)
    _5 := builtin$havoc_ref()
    inhale acc(_5.val_ref, write)
    _5.val_ref := mut borrow _1.val_ref.f$state[enum_Specialized].f$0 // L0
    label l2
    // [mir] StorageLive(_6)
    // [mir] _6 = &'?4 mut (*_5)
    _6 := builtin$havoc_ref()
    inhale acc(_6.val_ref, write)
    _6.val_ref := mut borrow _5.val_ref // L1
    label l3
    // [mir] _0 = specialized::pclmulqdq::State::reset(move _6) -> [return: bb6, unwind: bb8]
    label l4
    assert true
    assert (true) && (true)
    exhale (acc(_6.val_ref, write)) && ((acc(struct$m_specialized$$pclmulqdq$$State(_6.val_ref), write)) && (true))
    _0 := builtin$havoc_ref()
    inhale (acc(struct$m_specialized$$pclmulqdq$$State(old[l4](_6.val_ref)), write)) && (true)
    inhale acc(tuple0$(_0), write)
    inhale (true) && ((true) && (true))
    inhale true
    exhale true
    label l5
    Goto(cfg:7)
  label l6 // 7
    // ========== l6 ==========
    // MIR edge bb2 --> bb6
    // Expire borrows
    expire_borrows ReborrowingDAG(L8,L1,L0,)

    Goto(cfg:8)
  label bb6 // 8
    // ========== bb6 ==========
    __t3 := copy true
    // [mir] StorageDead(_6)
    // [mir] StorageDead(_5)
    // [mir] goto -> bb7
    Goto(cfg:13)
  label bb1 // 9
    // ========== bb1 ==========
    __t4 := copy true
    // [mir] falseEdge -> [real: bb4, imaginary: bb2]
    Goto(cfg:10)
  label bb4 // 10
    // ========== bb4 ==========
    __t5 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = &'?5 mut ((((*_1).1: State) as Baseline).0: baseline::State)
    _3 := builtin$havoc_ref()
    inhale acc(_3.val_ref, write)
    _3.val_ref := mut borrow _1.val_ref.f$state[enum_Baseline].f$0 // L2
    label l7
    // [mir] StorageLive(_4)
    // [mir] _4 = &'?6 mut (*_3)
    _4 := builtin$havoc_ref()
    inhale acc(_4.val_ref, write)
    _4.val_ref := mut borrow _3.val_ref // L3
    label l8
    // [mir] _0 = baseline::State::reset(move _4) -> [return: bb5, unwind: bb8]
    label l9
    assert true
    assert (true) && (true)
    exhale (acc(_4.val_ref, write)) && ((acc(struct$m_baseline$$State(_4.val_ref), write)) && (true))
    _0 := builtin$havoc_ref()
    inhale (acc(struct$m_baseline$$State(old[l9](_4.val_ref)), write)) && (true)
    inhale acc(tuple0$(_0), write)
    inhale (true) && ((true) && (true))
    inhale true
    exhale true
    label l10
    Goto(cfg:11)
  label l11 // 11
    // ========== l11 ==========
    // MIR edge bb4 --> bb5
    // Expire borrows
    expire_borrows ReborrowingDAG(L7,L3,L2,)

    Goto(cfg:12)
  label bb5 // 12
    // ========== bb5 ==========
    __t6 := copy true
    // [mir] StorageDead(_4)
    // [mir] StorageDead(_3)
    // [mir] goto -> bb7
    Goto(cfg:13)
  label bb7 // 13
    // ========== bb7 ==========
    __t7 := copy true
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_Hasher$$combine(...)
    returns (_0: Ref(tuple0$))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    __t4: Bool
    __t5: Bool
    __t6: Bool
    __t7: Bool
    __t8: Bool
    __t9: Bool
    __t10: Bool
    __t11: Bool
    __t12: Int
    _old$pre$0: Ref(struct$m_Hasher)
    _old$pre$1: Ref(struct$m_Hasher)
    _1: Ref(ref$struct$m_Hasher)
    _2: Ref(ref$struct$m_Hasher)
    _3: Ref(u64)
    _4: Ref(tuple2$u64$bool)
    _5: Ref(u32)
    _6: Ref(struct$m_Hasher)
    _7: Ref(ref$struct$m_Hasher)
    _8: Ref(isize)
    _9: Ref(ref$struct$m_baseline$$State)
    _10: Ref(ref$struct$m_baseline$$State)
    _11: Ref(u32)
    _12: Ref(u64)
    _13: Ref(ref$struct$m_specialized$$pclmulqdq$$State)
    _14: Ref(ref$struct$m_specialized$$pclmulqdq$$State)
    _15: Ref(u32)
    _16: Ref(u64)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::{impl#0}::combine"
    // Span: src/lib.rs:128:5: 135:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    __t4 := copy false
    __t5 := copy false
    __t6 := copy false
    __t7 := copy false
    __t8 := copy false
    __t9 := copy false
    __t10 := copy false
    // Preconditions:
    inhale (acc(_1.val_ref, write)) && ((acc(struct$m_Hasher(_1.val_ref), write)) && ((acc(_2.val_ref, write)) && ((acc(struct$m_Hasher(_2.val_ref), read)) && (true))))
    inhale true
    inhale (true) && ((true) && (true))
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l25
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(struct$m_Hasher(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(struct$m_Hasher(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(tuple0$(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && ((true) && (true))
    // Exhale permissions of postcondition (1/3)
    exhale (acc(struct$m_Hasher(_old$pre$0), write)) && ((acc(struct$m_Hasher(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(tuple0$(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = ((*_2).0: u64)
    _3 := builtin$havoc_ref()
    inhale acc(_3.val_int, write)
    _3.val_int := copy _2.val_ref.f$amount.val_int
    label l0
    // [mir] _4 = CheckedAdd(((*_1).0: u64), _3)
    _4 := builtin$havoc_ref()
    inhale acc(_4.tuple_0, write)
    inhale acc(_4.tuple_0.val_int, write)
    inhale acc(_4.tuple_1, write)
    inhale acc(_4.tuple_1.val_bool, write)
    _4.tuple_0.val_int := copy (_1.val_ref.f$amount.val_int) + (_3.val_int)
    _4.tuple_1.val_bool := copy (((_1.val_ref.f$amount.val_int) + (_3.val_int)) < (0)) || (((_1.val_ref.f$amount.val_int) + (_3.val_int)) > (18446744073709551615))
    // [mir] assert(!move (_4.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).0: u64), move _3) -> [success: bb1, unwind: bb11]
    __t11 := copy _4.tuple_1.val_bool
    // Rust assertion: attempt to add with overflow
    assert !(__t11)
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] ((*_1).0: u64) = move (_4.0: u64)
    _1.val_ref.f$amount := move _4.tuple_0
    label l1
    // [mir] StorageDead(_3)
    // [mir] StorageLive(_5)
    // [mir] StorageLive(_6)
    // [mir] StorageLive(_7)
    // [mir] _7 = &'?4 (*_2)
    _7 := builtin$havoc_ref()
    inhale acc(_7.val_ref, write)
    _7.val_ref := borrow _2.val_ref // L11
    label l2
    // [mir] _6 = <Hasher as std::clone::Clone>::clone(move _7) -> [return: bb2, unwind: bb11]
    label l3
    assert true
    assert (true) && (true)
    exhale (acc(_7.val_ref, write)) && ((true) && (true))
    _6 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_Hasher(_6), write)
    transfer perm _7.val_ref --> old[l3](_7.val_ref) // unchecked: true
    inhale (true) && (true)
    inhale true
    exhale true
    label l4
    Goto(cfg:4)
  label l5 // 4
    // ========== l5 ==========
    // MIR edge bb1 --> bb2
    // Expire borrows
    expire_borrows ReborrowingDAG(L10,L11,)

    Goto(cfg:5)
  label bb2 // 5
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] StorageDead(_7)
    // [mir] _5 = Hasher::finalize(move _6) -> [return: bb3, unwind: bb11]
    label l6
    assert true
    assert (true) && (true)
    exhale (acc(struct$m_Hasher(_6), write)) && (true)
    _5 := builtin$havoc_ref()
    inhale true
    inhale acc(u32(_5), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l7
    Goto(cfg:6)
  label bb3 // 6
    // ========== bb3 ==========
    __t3 := copy true
    // [mir] StorageDead(_6)
    // [mir] FakeRead(ForLet(None), _5)
    // [mir] FakeRead(ForMatchedPlace(None), ((*_1).1: State))
    // [mir] _8 = discriminant(((*_1).1: State))
    _8 := builtin$havoc_ref()
    inhale acc(_8.val_int, write)
    _8.val_int := copy m_State$_beg_$_end_$$discriminant$$<>(_1.val_ref.f$state)
    // [mir] switchInt(move _8) -> [0: bb4, 1: bb5, otherwise: bb6]
    __t12 := copy _8.val_int
    // Ignore default target bb6, as the compiler marked it as unreachable.
    GotoSwitch([(BinOp(BinOp { op_kind: EqCmp, left: Local(Local { variable: __t12: Int, position: Position { line: 0, column: 0, id: 0 } }), right: Const(ConstExpr { value: BigInt("0"), position: Position { line: 0, column: 0, id: 0 } }), position: Position { line: 0, column: 0, id: 0 } }), cfg:8)], cfg:7)
  label l8 // 7
    // ========== l8 ==========
    // MIR edge bb3 --> bb5
    Goto(cfg:10)
  label l9 // 8
    // ========== l9 ==========
    // MIR edge bb3 --> bb4
    Goto(cfg:13)
  label bb6 // 9
    // ========== bb6 ==========
    __t4 := copy true
    // [mir] unreachable
    Return
  label bb5 // 10
    // ========== bb5 ==========
    __t5 := copy true
    // [mir] StorageLive(_13)
    // [mir] _13 = &'?5 mut ((((*_1).1: State) as Specialized).0: specialized::pclmulqdq::State)
    _13 := builtin$havoc_ref()
    inhale acc(_13.val_ref, write)
    _13.val_ref := mut borrow _1.val_ref.f$state[enum_Specialized].f$0 // L0
    label l10
    // [mir] StorageLive(_14)
    // [mir] _14 = &'?6 mut (*_13)
    _14 := builtin$havoc_ref()
    inhale acc(_14.val_ref, write)
    _14.val_ref := mut borrow _13.val_ref // L1
    label l11
    // [mir] StorageLive(_15)
    // [mir] _15 = _5
    _15 := builtin$havoc_ref()
    inhale acc(_15.val_int, write)
    _15.val_int := copy _5.val_int
    label l12
    // [mir] StorageLive(_16)
    // [mir] _16 = ((*_2).0: u64)
    _16 := builtin$havoc_ref()
    inhale acc(_16.val_int, write)
    _16.val_int := copy _2.val_ref.f$amount.val_int
    label l13
    // [mir] _0 = specialized::pclmulqdq::State::combine(move _14, move _15, move _16) -> [return: bb9, unwind: bb11]
    label l14
    assert true
    assert (true) && ((true) && ((true) && (true)))
    exhale (acc(_14.val_ref, write)) && ((acc(struct$m_specialized$$pclmulqdq$$State(_14.val_ref), write)) && ((acc(u32(_15), write)) && ((acc(u64(_16), write)) && (true))))
    _0 := builtin$havoc_ref()
    inhale (acc(struct$m_specialized$$pclmulqdq$$State(old[l14](_14.val_ref)), write)) && (true)
    inhale acc(tuple0$(_0), write)
    inhale (true) && ((true) && (true))
    inhale true
    exhale true
    label l15
    Goto(cfg:11)
  label l16 // 11
    // ========== l16 ==========
    // MIR edge bb5 --> bb9
    // Expire borrows
    expire_borrows ReborrowingDAG(L8,L1,L0,)

    Goto(cfg:12)
  label bb9 // 12
    // ========== bb9 ==========
    __t6 := copy true
    // [mir] StorageDead(_16)
    // [mir] StorageDead(_15)
    // [mir] StorageDead(_14)
    // [mir] StorageDead(_13)
    // [mir] goto -> bb10
    Goto(cfg:17)
  label bb4 // 13
    // ========== bb4 ==========
    __t7 := copy true
    // [mir] falseEdge -> [real: bb7, imaginary: bb5]
    Goto(cfg:14)
  label bb7 // 14
    // ========== bb7 ==========
    __t8 := copy true
    // [mir] StorageLive(_9)
    // [mir] _9 = &'?7 mut ((((*_1).1: State) as Baseline).0: baseline::State)
    _9 := builtin$havoc_ref()
    inhale acc(_9.val_ref, write)
    _9.val_ref := mut borrow _1.val_ref.f$state[enum_Baseline].f$0 // L2
    label l17
    // [mir] StorageLive(_10)
    // [mir] _10 = &'?8 mut (*_9)
    _10 := builtin$havoc_ref()
    inhale acc(_10.val_ref, write)
    _10.val_ref := mut borrow _9.val_ref // L3
    label l18
    // [mir] StorageLive(_11)
    // [mir] _11 = _5
    _11 := builtin$havoc_ref()
    inhale acc(_11.val_int, write)
    _11.val_int := copy _5.val_int
    label l19
    // [mir] StorageLive(_12)
    // [mir] _12 = ((*_2).0: u64)
    _12 := builtin$havoc_ref()
    inhale acc(_12.val_int, write)
    _12.val_int := copy _2.val_ref.f$amount.val_int
    label l20
    // [mir] _0 = baseline::State::combine(move _10, move _11, move _12) -> [return: bb8, unwind: bb11]
    label l21
    assert true
    assert (true) && ((true) && ((true) && (true)))
    exhale (acc(_10.val_ref, write)) && ((acc(struct$m_baseline$$State(_10.val_ref), write)) && ((acc(u32(_11), write)) && ((acc(u64(_12), write)) && (true))))
    _0 := builtin$havoc_ref()
    inhale (acc(struct$m_baseline$$State(old[l21](_10.val_ref)), write)) && (true)
    inhale acc(tuple0$(_0), write)
    inhale (true) && ((true) && (true))
    inhale true
    exhale true
    label l22
    Goto(cfg:15)
  label l23 // 15
    // ========== l23 ==========
    // MIR edge bb7 --> bb8
    // Expire borrows
    expire_borrows ReborrowingDAG(L9,L3,L2,)

    Goto(cfg:16)
  label bb8 // 16
    // ========== bb8 ==========
    __t9 := copy true
    // [mir] StorageDead(_12)
    // [mir] StorageDead(_11)
    // [mir] StorageDead(_10)
    // [mir] StorageDead(_9)
    // [mir] goto -> bb10
    Goto(cfg:17)
  label bb10 // 17
    // ========== bb10 ==========
    __t10 := copy true
    // [mir] StorageDead(_5)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_$openang$Hasher$space$as$space$std$$fmt$$Debug$closeang$$$fmt(...)
    returns (_0: Ref(m_std$$result$$Result$_beg_$tuple0$$_sep_$struct$m_std$$fmt$$Error$_end_))
{
  label stub // 0
    // ========== stub ==========
    // Def path: "crc32fast::{impl#1}::fmt"
    // Span: src/lib.rs:139:5: 141:6 (#0)
    Return
  label end_of_method
}


method m_$openang$Hasher$space$as$space$std$$default$$Default$closeang$$$default(...)
    returns (_0: Ref(struct$m_Hasher))
{
    __t0: Bool
    __t1: Bool
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::{impl#2}::default"
    // Span: src/lib.rs:145:5: 147:6 (#0)
    __t0 := copy false
    __t1 := copy false
    // Preconditions:
    inhale true
    inhale true
    inhale true
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l3
    // Fold predicates for &mut args and transfer borrow permissions to old
    // Fold the result
    obtain acc(struct$m_Hasher(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale true
    // Exhale permissions of postcondition (2/3)
    exhale acc(struct$m_Hasher(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] _0 = Hasher::new() -> [return: bb1, unwind: bb2]
    label l0
    assert true
    assert true
    exhale true
    _0 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_Hasher(_0), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l1
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_$openang$Hasher$space$as$space$std$$hash$$Hasher$closeang$$$write(...)
    returns (_0: Ref(tuple0$))
{
    __t0: Bool
    __t1: Bool
    _old$pre$0: Ref(struct$m_Hasher)
    _old$pre$1: Ref(Slice$u8)
    _1: Ref(ref$struct$m_Hasher)
    _2: Ref(ref$Slice$u8)
    _3: Ref(ref$struct$m_Hasher)
    _4: Ref(ref$Slice$u8)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::{impl#3}::write"
    // Span: src/lib.rs:151:5: 153:6 (#0)
    __t0 := copy false
    __t1 := copy false
    // Preconditions:
    inhale (acc(_1.val_ref, write)) && ((acc(struct$m_Hasher(_1.val_ref), write)) && ((acc(_2.val_ref, write)) && ((acc(Slice$u8(_2.val_ref), read)) && (true))))
    inhale true
    inhale (true) && ((true) && (true))
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l6
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(struct$m_Hasher(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    obtain acc(Slice$u8(_2.val_ref), write)
    _old$pre$1 := move _2.val_ref
    // Fold the result
    obtain acc(tuple0$(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && ((true) && (true))
    // Exhale permissions of postcondition (1/3)
    exhale (acc(struct$m_Hasher(_old$pre$0), write)) && ((acc(Slice$u8(_old$pre$1), read)) && (true))
    // Exhale permissions of postcondition (2/3)
    exhale acc(tuple0$(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_3)
    // [mir] _3 = &'?4 mut (*_1)
    _3 := builtin$havoc_ref()
    inhale acc(_3.val_ref, write)
    _3.val_ref := mut borrow _1.val_ref // L0
    label l0
    // [mir] StorageLive(_4)
    // [mir] _4 = &'?5 (*_2)
    _4 := builtin$havoc_ref()
    inhale acc(_4.val_ref, write)
    _4.val_ref := borrow _2.val_ref // L5
    label l1
    // [mir] _0 = Hasher::update(move _3, move _4) -> [return: bb1, unwind: bb2]
    label l2
    assert true
    assert (true) && ((true) && (true))
    exhale (acc(_3.val_ref, write)) && ((acc(struct$m_Hasher(_3.val_ref), write)) && ((acc(_4.val_ref, write)) && ((true) && (true))))
    _0 := builtin$havoc_ref()
    inhale (acc(struct$m_Hasher(old[l2](_3.val_ref)), write)) && (true)
    inhale acc(tuple0$(_0), write)
    transfer perm _4.val_ref --> old[l2](_4.val_ref) // unchecked: true
    inhale (true) && ((true) && (true))
    inhale true
    exhale true
    label l3
    Goto(cfg:3)
  label l4 // 3
    // ========== l4 ==========
    // MIR edge bb0 --> bb1
    // Expire borrows
    expire_borrows ReborrowingDAG(L7,L6,L5,L0,)

    Goto(cfg:4)
  label bb1 // 4
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_4)
    // [mir] StorageDead(_3)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_$openang$Hasher$space$as$space$std$$hash$$Hasher$closeang$$$finish(...)
    returns (_0: Ref(u64))
{
    __t0: Bool
    __t1: Bool
    __t2: Bool
    __t3: Bool
    _old$pre$0: Ref(struct$m_Hasher)
    _1: Ref(ref$struct$m_Hasher)
    _2: Ref(u32)
    _3: Ref(struct$m_Hasher)
    _4: Ref(ref$struct$m_Hasher)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::{impl#3}::finish"
    // Span: src/lib.rs:155:5: 157:6 (#0)
    __t0 := copy false
    __t1 := copy false
    __t2 := copy false
    __t3 := copy false
    // Preconditions:
    inhale (acc(_1.val_ref, write)) && ((acc(struct$m_Hasher(_1.val_ref), read)) && (true))
    inhale true
    inhale (true) && (true)
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l9
    // Fold predicates for &mut args and transfer borrow permissions to old
    obtain acc(struct$m_Hasher(_1.val_ref), write)
    _old$pre$0 := move _1.val_ref
    // Fold the result
    obtain acc(u64(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale (acc(struct$m_Hasher(_old$pre$0), read)) && (true)
    // Exhale permissions of postcondition (2/3)
    exhale acc(u64(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_2)
    // [mir] StorageLive(_3)
    // [mir] StorageLive(_4)
    // [mir] _4 = &'?3 (*_1)
    _4 := builtin$havoc_ref()
    inhale acc(_4.val_ref, write)
    _4.val_ref := borrow _1.val_ref // L4
    label l0
    // [mir] _3 = <Hasher as std::clone::Clone>::clone(move _4) -> [return: bb1, unwind: bb4]
    label l1
    assert true
    assert (true) && (true)
    exhale (acc(_4.val_ref, write)) && ((true) && (true))
    _3 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_Hasher(_3), write)
    transfer perm _4.val_ref --> old[l1](_4.val_ref) // unchecked: true
    inhale (true) && (true)
    inhale true
    exhale true
    label l2
    Goto(cfg:3)
  label l3 // 3
    // ========== l3 ==========
    // MIR edge bb0 --> bb1
    // Expire borrows
    expire_borrows ReborrowingDAG(L3,L4,)

    Goto(cfg:4)
  label bb1 // 4
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_4)
    // [mir] _2 = Hasher::finalize(move _3) -> [return: bb2, unwind: bb4]
    label l4
    assert true
    assert (true) && (true)
    exhale (acc(struct$m_Hasher(_3), write)) && (true)
    _2 := builtin$havoc_ref()
    inhale true
    inhale acc(u32(_2), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l5
    Goto(cfg:5)
  label bb2 // 5
    // ========== bb2 ==========
    __t2 := copy true
    // [mir] StorageDead(_3)
    // [mir] _0 = <u64 as std::convert::From<u32>>::from(move _2) -> [return: bb3, unwind: bb4]
    label l6
    assert true
    assert (true) && (true)
    exhale (acc(u32(_2), write)) && (true)
    _0 := builtin$havoc_ref()
    inhale true
    inhale acc(u64(_0), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l7
    Goto(cfg:6)
  label bb3 // 6
    // ========== bb3 ==========
    __t3 := copy true
    // [mir] StorageDead(_2)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


method m_Hasher$$new_with_initial$$$opencur$closure$sharp$0$closecur$(...)
    returns (_0: Ref(struct$m_Hasher))
{
    __t0: Bool
    __t1: Bool
    _1: Ref(closure$m_Hasher$$new_with_initial$$$opencur$closure$sharp$0$closecur$)
    _2: Ref(u32)
  label start // 0
    // ========== start ==========
    // Def path: "crc32fast::{impl#0}::new_with_initial::{closure#0}"
    // Span: src/lib.rs:75:61: 75:97 (#0)
    __t0 := copy false
    __t1 := copy false
    // Preconditions:
    inhale (acc(closure$m_Hasher$$new_with_initial$$$opencur$closure$sharp$0$closecur$(_1), write)) && (true)
    inhale true
    inhale (true) && (true)
    inhale true
    label pre
    Goto(cfg:2)
  label return // 1
    // ========== return ==========
    // Target of any 'return' statement.
    // Exhale postcondition
    label l4
    // Fold predicates for &mut args and transfer borrow permissions to old
    // Fold the result
    obtain acc(struct$m_Hasher(_0), write)
    // Assert possible strengthening
    // Assert functional specification of postcondition
    assert true
    // Assert type invariants
    assert (true) && (true)
    // Exhale permissions of postcondition (1/3)
    exhale true
    // Exhale permissions of postcondition (2/3)
    exhale acc(struct$m_Hasher(_0), write)
    // Exhale permissions of postcondition (3/3)
    Return
  label bb0 // 2
    // ========== bb0 ==========
    __t0 := copy true
    // [mir] StorageLive(_2)
    // [mir] _2 = (*(_1.0: &'?3 u32))
    _2 := builtin$havoc_ref()
    inhale acc(_2.val_int, write)
    _2.val_int := copy _1.closure_0.val_ref.val_int
    label l0
    // [mir] _0 = Hasher::internal_new_baseline(move _2) -> [return: bb1, unwind: bb2]
    label l1
    assert true
    assert (true) && (true)
    exhale (acc(u32(_2), write)) && (true)
    _0 := builtin$havoc_ref()
    inhale true
    inhale acc(struct$m_Hasher(_0), write)
    inhale (true) && (true)
    inhale true
    exhale true
    label l2
    Goto(cfg:3)
  label bb1 // 3
    // ========== bb1 ==========
    __t1 := copy true
    // [mir] StorageDead(_2)
    // [mir] return
    Goto(cfg:1)
  label end_of_method
}


